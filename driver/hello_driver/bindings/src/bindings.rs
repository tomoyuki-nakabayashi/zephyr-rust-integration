/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
pub const CONFIG_BOARD: &'static [u8; 15usize] = b"qemu_cortex_m3\0";
pub const CONFIG_SOC: &'static [u8; 12usize] = b"ti_lm3s6965\0";
pub const CONFIG_NUM_IRQS: u32 = 43;
pub const CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC: u32 = 12000000;
pub const CONFIG_ISR_STACK_SIZE: u32 = 2048;
pub const CONFIG_SYS_CLOCK_TICKS_PER_SEC: u32 = 100;
pub const CONFIG_UART_STELLARIS_PORT_1: u32 = 1;
pub const CONFIG_UART_STELLARIS_PORT_2: u32 = 1;
pub const CONFIG_TEXT_SECTION_OFFSET: u32 = 0;
pub const CONFIG_QEMU_TARGET: u32 = 1;
pub const CONFIG_BOARD_QEMU_CORTEX_M3: u32 = 1;
pub const CONFIG_SOC_TI_LM3S6965: u32 = 1;
pub const CONFIG_SOC_TI_LM3S6965_QEMU: u32 = 1;
pub const CONFIG_CPU_CORTEX: u32 = 1;
pub const CONFIG_CPU_CORTEX_M: u32 = 1;
pub const CONFIG_CPU_HAS_SYSTICK: u32 = 1;
pub const CONFIG_CPU_CORTEX_M3: u32 = 1;
pub const CONFIG_ISA_THUMB2: u32 = 1;
pub const CONFIG_CPU_CORTEX_M_HAS_BASEPRI: u32 = 1;
pub const CONFIG_CPU_CORTEX_M_HAS_VTOR: u32 = 1;
pub const CONFIG_CPU_CORTEX_M_HAS_PROGRAMMABLE_FAULT_PRIOS: u32 = 1;
pub const CONFIG_ARMV7_M_ARMV8_M_MAINLINE: u32 = 1;
pub const CONFIG_LDREX_STREX_AVAILABLE: u32 = 1;
pub const CONFIG_DATA_ENDIANNESS_LITTLE: u32 = 1;
pub const CONFIG_STACK_ALIGN_DOUBLE_WORD: u32 = 1;
pub const CONFIG_FAULT_DUMP: u32 = 2;
pub const CONFIG_XIP: u32 = 1;
pub const CONFIG_GEN_ISR_TABLES: u32 = 1;
pub const CONFIG_ARCH: &'static [u8; 4usize] = b"arm\0";
pub const CONFIG_ARCH_DEFCONFIG: &'static [u8; 19usize] = b"arch/arm/defconfig\0";
pub const CONFIG_ARM: u32 = 1;
pub const CONFIG_GEN_IRQ_VECTOR_TABLE: u32 = 1;
pub const CONFIG_GEN_SW_ISR_TABLE: u32 = 1;
pub const CONFIG_GEN_IRQ_START_VECTOR: u32 = 0;
pub const CONFIG_ARCH_HAS_THREAD_ABORT: u32 = 1;
pub const CONFIG_MULTITHREADING: u32 = 1;
pub const CONFIG_NUM_COOP_PRIORITIES: u32 = 16;
pub const CONFIG_NUM_PREEMPT_PRIORITIES: u32 = 15;
pub const CONFIG_MAIN_THREAD_PRIORITY: u32 = 0;
pub const CONFIG_COOP_ENABLED: u32 = 1;
pub const CONFIG_PREEMPT_ENABLED: u32 = 1;
pub const CONFIG_PRIORITY_CEILING: u32 = 0;
pub const CONFIG_NUM_METAIRQ_PRIORITIES: u32 = 0;
pub const CONFIG_MAIN_STACK_SIZE: u32 = 1024;
pub const CONFIG_IDLE_STACK_SIZE: u32 = 256;
pub const CONFIG_ERRNO: u32 = 1;
pub const CONFIG_SCHED_MULTIQ: u32 = 1;
pub const CONFIG_WAITQ_DUMB: u32 = 1;
pub const CONFIG_BOOT_BANNER: u32 = 1;
pub const CONFIG_BOOT_DELAY: u32 = 0;
pub const CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE: u32 = 1024;
pub const CONFIG_SYSTEM_WORKQUEUE_PRIORITY: i32 = -1;
pub const CONFIG_OFFLOAD_WORKQUEUE_STACK_SIZE: u32 = 1024;
pub const CONFIG_OFFLOAD_WORKQUEUE_PRIORITY: i32 = -1;
pub const CONFIG_ATOMIC_OPERATIONS_BUILTIN: u32 = 1;
pub const CONFIG_TIMESLICING: u32 = 1;
pub const CONFIG_TIMESLICE_SIZE: u32 = 0;
pub const CONFIG_TIMESLICE_PRIORITY: u32 = 0;
pub const CONFIG_NUM_MBOX_ASYNC_MSGS: u32 = 10;
pub const CONFIG_NUM_PIPE_ASYNC_MSGS: u32 = 10;
pub const CONFIG_HEAP_MEM_POOL_SIZE: u32 = 0;
pub const CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN: u32 = 1;
pub const CONFIG_SYS_CLOCK_EXISTS: u32 = 1;
pub const CONFIG_KERNEL_INIT_PRIORITY_OBJECTS: u32 = 30;
pub const CONFIG_KERNEL_INIT_PRIORITY_DEFAULT: u32 = 40;
pub const CONFIG_KERNEL_INIT_PRIORITY_DEVICE: u32 = 50;
pub const CONFIG_APPLICATION_INIT_PRIORITY: u32 = 90;
pub const CONFIG_RETPOLINE: u32 = 1;
pub const CONFIG_STACK_POINTER_RANDOM: u32 = 0;
pub const CONFIG_MP_NUM_CPUS: u32 = 1;
pub const CONFIG_TICKLESS_IDLE: u32 = 1;
pub const CONFIG_TICKLESS_IDLE_THRESH: u32 = 3;
pub const CONFIG_TICKLESS_KERNEL: u32 = 1;
pub const CONFIG_HAS_DTS: u32 = 1;
pub const CONFIG_CONSOLE: u32 = 1;
pub const CONFIG_CONSOLE_INPUT_MAX_LINE_LEN: u32 = 128;
pub const CONFIG_CONSOLE_HAS_DRIVER: u32 = 1;
pub const CONFIG_UART_CONSOLE: u32 = 1;
pub const CONFIG_UART_CONSOLE_INIT_PRIORITY: u32 = 60;
pub const CONFIG_SERIAL: u32 = 1;
pub const CONFIG_SERIAL_HAS_DRIVER: u32 = 1;
pub const CONFIG_SERIAL_SUPPORT_INTERRUPT: u32 = 1;
pub const CONFIG_UART_STELLARIS: u32 = 1;
pub const CONFIG_CORTEX_M_SYSTICK: u32 = 1;
pub const CONFIG_SYSTEM_CLOCK_INIT_PRIORITY: u32 = 0;
pub const CONFIG_TICKLESS_CAPABLE: u32 = 1;
pub const CONFIG_NEWLIB_LIBC: u32 = 1;
pub const CONFIG_STDOUT_CONSOLE: u32 = 1;
pub const CONFIG_POSIX_MAX_FDS: u32 = 4;
pub const CONFIG_STD_CPP11: u32 = 1;
pub const CONFIG_PRINTK: u32 = 1;
pub const CONFIG_EARLY_CONSOLE: u32 = 1;
pub const CONFIG_HAS_CMSIS: u32 = 1;
pub const CONFIG_LIBMETAL_SRC_PATH: &'static [u8; 9usize] = b"libmetal\0";
pub const CONFIG_OPENAMP_SRC_PATH: &'static [u8; 9usize] = b"open-amp\0";
pub const CONFIG_TEST_EXTRA_STACKSIZE: u32 = 0;
pub const CONFIG_LINKER_ORPHAN_SECTION_WARN: u32 = 1;
pub const CONFIG_HAS_FLASH_LOAD_OFFSET: u32 = 1;
pub const CONFIG_KERNEL_ENTRY: &'static [u8; 8usize] = b"__start\0";
pub const CONFIG_CHECK_LINK_MAP: u32 = 1;
pub const CONFIG_SIZE_OPTIMIZATIONS: u32 = 1;
pub const CONFIG_COMPILER_OPT: &'static [u8; 1usize] = b"\0";
pub const CONFIG_KERNEL_BIN_NAME: &'static [u8; 7usize] = b"zephyr\0";
pub const CONFIG_OUTPUT_STAT: u32 = 1;
pub const CONFIG_OUTPUT_DISASSEMBLY: u32 = 1;
pub const CONFIG_OUTPUT_PRINT_MEMORY_USAGE: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const __WORDSIZE32_SIZE_ULONG: u32 = 0;
pub const __WORDSIZE32_PTRDIFF_LONG: u32 = 0;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 0;
pub const __FD_SETSIZE: u32 = 1024;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const UTIL_INC_0: u32 = 1;
pub const UTIL_INC_1: u32 = 2;
pub const UTIL_INC_2: u32 = 3;
pub const UTIL_INC_3: u32 = 4;
pub const UTIL_INC_4: u32 = 5;
pub const UTIL_INC_5: u32 = 6;
pub const UTIL_INC_6: u32 = 7;
pub const UTIL_INC_7: u32 = 8;
pub const UTIL_INC_8: u32 = 9;
pub const UTIL_INC_9: u32 = 10;
pub const UTIL_INC_10: u32 = 11;
pub const UTIL_INC_11: u32 = 12;
pub const UTIL_INC_12: u32 = 13;
pub const UTIL_INC_13: u32 = 14;
pub const UTIL_INC_14: u32 = 15;
pub const UTIL_INC_15: u32 = 16;
pub const UTIL_INC_16: u32 = 17;
pub const UTIL_INC_17: u32 = 18;
pub const UTIL_INC_18: u32 = 19;
pub const UTIL_INC_19: u32 = 19;
pub const UTIL_DEC_0: u32 = 0;
pub const UTIL_DEC_1: u32 = 0;
pub const UTIL_DEC_2: u32 = 1;
pub const UTIL_DEC_3: u32 = 2;
pub const UTIL_DEC_4: u32 = 3;
pub const UTIL_DEC_5: u32 = 4;
pub const UTIL_DEC_6: u32 = 5;
pub const UTIL_DEC_7: u32 = 6;
pub const UTIL_DEC_8: u32 = 7;
pub const UTIL_DEC_9: u32 = 8;
pub const UTIL_DEC_10: u32 = 9;
pub const UTIL_DEC_11: u32 = 10;
pub const UTIL_DEC_12: u32 = 11;
pub const UTIL_DEC_13: u32 = 12;
pub const UTIL_DEC_14: u32 = 13;
pub const UTIL_DEC_15: u32 = 14;
pub const UTIL_DEC_16: u32 = 15;
pub const UTIL_DEC_17: u32 = 16;
pub const UTIL_DEC_18: u32 = 17;
pub const UTIL_DEC_19: u32 = 18;
pub const UTIL_DEC_20: u32 = 19;
pub const UTIL_DEC_21: u32 = 20;
pub const UTIL_DEC_22: u32 = 21;
pub const UTIL_DEC_23: u32 = 22;
pub const UTIL_DEC_24: u32 = 23;
pub const UTIL_DEC_25: u32 = 24;
pub const UTIL_DEC_26: u32 = 25;
pub const UTIL_DEC_27: u32 = 26;
pub const UTIL_DEC_28: u32 = 27;
pub const UTIL_DEC_29: u32 = 28;
pub const UTIL_DEC_30: u32 = 29;
pub const UTIL_DEC_31: u32 = 30;
pub const UTIL_DEC_32: u32 = 31;
pub const UTIL_DEC_33: u32 = 32;
pub const UTIL_DEC_34: u32 = 33;
pub const UTIL_DEC_35: u32 = 34;
pub const UTIL_DEC_36: u32 = 35;
pub const UTIL_DEC_37: u32 = 36;
pub const UTIL_DEC_38: u32 = 37;
pub const UTIL_DEC_39: u32 = 38;
pub const UTIL_DEC_40: u32 = 39;
pub const UTIL_COMPL_0: u32 = 1;
pub const UTIL_COMPL_1: u32 = 0;
pub const SYS_SFLIST_FLAGS_MASK: u32 = 3;
pub const K_SYSCALL_AIO_CMP_DISABLE: u32 = 0;
pub const K_SYSCALL_AIO_CMP_GET_PENDING_INT: u32 = 1;
pub const K_SYSCALL_CAN_ATTACH_ISR: u32 = 2;
pub const K_SYSCALL_CAN_ATTACH_MSGQ: u32 = 3;
pub const K_SYSCALL_CAN_CONFIGURE: u32 = 4;
pub const K_SYSCALL_CAN_DETACH: u32 = 5;
pub const K_SYSCALL_CAN_SEND: u32 = 6;
pub const K_SYSCALL_COUNTER_GET_PENDING_INT: u32 = 7;
pub const K_SYSCALL_COUNTER_READ: u32 = 8;
pub const K_SYSCALL_COUNTER_START: u32 = 9;
pub const K_SYSCALL_COUNTER_STOP: u32 = 10;
pub const K_SYSCALL_DEVICE_GET_BINDING: u32 = 11;
pub const K_SYSCALL_DMA_START: u32 = 12;
pub const K_SYSCALL_DMA_STOP: u32 = 13;
pub const K_SYSCALL_ENTROPY_GET_ENTROPY: u32 = 14;
pub const K_SYSCALL_FLASH_ERASE: u32 = 15;
pub const K_SYSCALL_FLASH_GET_PAGE_COUNT: u32 = 16;
pub const K_SYSCALL_FLASH_GET_PAGE_INFO_BY_IDX: u32 = 17;
pub const K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS: u32 = 18;
pub const K_SYSCALL_FLASH_GET_WRITE_BLOCK_SIZE: u32 = 19;
pub const K_SYSCALL_FLASH_READ: u32 = 20;
pub const K_SYSCALL_FLASH_WRITE: u32 = 21;
pub const K_SYSCALL_FLASH_WRITE_PROTECTION_SET: u32 = 22;
pub const K_SYSCALL_GPIO_CONFIG: u32 = 23;
pub const K_SYSCALL_GPIO_DISABLE_CALLBACK: u32 = 24;
pub const K_SYSCALL_GPIO_ENABLE_CALLBACK: u32 = 25;
pub const K_SYSCALL_GPIO_GET_PENDING_INT: u32 = 26;
pub const K_SYSCALL_GPIO_READ: u32 = 27;
pub const K_SYSCALL_GPIO_WRITE: u32 = 28;
pub const K_SYSCALL_I2C_CONFIGURE: u32 = 29;
pub const K_SYSCALL_I2C_SLAVE_DRIVER_REGISTER: u32 = 30;
pub const K_SYSCALL_I2C_SLAVE_DRIVER_UNREGISTER: u32 = 31;
pub const K_SYSCALL_I2C_SLAVE_REGISTER: u32 = 32;
pub const K_SYSCALL_I2C_SLAVE_UNREGISTER: u32 = 33;
pub const K_SYSCALL_I2C_TRANSFER: u32 = 34;
pub const K_SYSCALL_I2S_BUF_READ: u32 = 35;
pub const K_SYSCALL_I2S_BUF_WRITE: u32 = 36;
pub const K_SYSCALL_I2S_CONFIGURE: u32 = 37;
pub const K_SYSCALL_I2S_TRIGGER: u32 = 38;
pub const K_SYSCALL_IPM_MAX_DATA_SIZE_GET: u32 = 39;
pub const K_SYSCALL_IPM_MAX_ID_VAL_GET: u32 = 40;
pub const K_SYSCALL_IPM_SEND: u32 = 41;
pub const K_SYSCALL_IPM_SET_ENABLED: u32 = 42;
pub const K_SYSCALL_K_ALERT_RECV: u32 = 43;
pub const K_SYSCALL_K_ALERT_SEND: u32 = 44;
pub const K_SYSCALL_K_BUSY_WAIT: u32 = 45;
pub const K_SYSCALL_K_CURRENT_GET: u32 = 46;
pub const K_SYSCALL_K_IS_PREEMPT_THREAD: u32 = 47;
pub const K_SYSCALL_K_MSGQ_ALLOC_INIT: u32 = 48;
pub const K_SYSCALL_K_MSGQ_GET: u32 = 49;
pub const K_SYSCALL_K_MSGQ_GET_ATTRS: u32 = 50;
pub const K_SYSCALL_K_MSGQ_NUM_FREE_GET: u32 = 51;
pub const K_SYSCALL_K_MSGQ_NUM_USED_GET: u32 = 52;
pub const K_SYSCALL_K_MSGQ_PEEK: u32 = 53;
pub const K_SYSCALL_K_MSGQ_PURGE: u32 = 54;
pub const K_SYSCALL_K_MSGQ_PUT: u32 = 55;
pub const K_SYSCALL_K_MUTEX_INIT: u32 = 56;
pub const K_SYSCALL_K_MUTEX_LOCK: u32 = 57;
pub const K_SYSCALL_K_MUTEX_UNLOCK: u32 = 58;
pub const K_SYSCALL_K_OBJECT_ACCESS_GRANT: u32 = 59;
pub const K_SYSCALL_K_OBJECT_ALLOC: u32 = 60;
pub const K_SYSCALL_K_OBJECT_RELEASE: u32 = 61;
pub const K_SYSCALL_K_PIPE_ALLOC_INIT: u32 = 62;
pub const K_SYSCALL_K_PIPE_GET: u32 = 63;
pub const K_SYSCALL_K_PIPE_PUT: u32 = 64;
pub const K_SYSCALL_K_POLL: u32 = 65;
pub const K_SYSCALL_K_POLL_SIGNAL_CHECK: u32 = 66;
pub const K_SYSCALL_K_POLL_SIGNAL_INIT: u32 = 67;
pub const K_SYSCALL_K_POLL_SIGNAL_RAISE: u32 = 68;
pub const K_SYSCALL_K_POLL_SIGNAL_RESET: u32 = 69;
pub const K_SYSCALL_K_QUEUE_ALLOC_APPEND: u32 = 70;
pub const K_SYSCALL_K_QUEUE_ALLOC_PREPEND: u32 = 71;
pub const K_SYSCALL_K_QUEUE_CANCEL_WAIT: u32 = 72;
pub const K_SYSCALL_K_QUEUE_GET: u32 = 73;
pub const K_SYSCALL_K_QUEUE_INIT: u32 = 74;
pub const K_SYSCALL_K_QUEUE_IS_EMPTY: u32 = 75;
pub const K_SYSCALL_K_QUEUE_PEEK_HEAD: u32 = 76;
pub const K_SYSCALL_K_QUEUE_PEEK_TAIL: u32 = 77;
pub const K_SYSCALL_K_SEM_COUNT_GET: u32 = 78;
pub const K_SYSCALL_K_SEM_GIVE: u32 = 79;
pub const K_SYSCALL_K_SEM_INIT: u32 = 80;
pub const K_SYSCALL_K_SEM_RESET: u32 = 81;
pub const K_SYSCALL_K_SEM_TAKE: u32 = 82;
pub const K_SYSCALL_K_SLEEP: u32 = 83;
pub const K_SYSCALL_K_STACK_ALLOC_INIT: u32 = 84;
pub const K_SYSCALL_K_STACK_POP: u32 = 85;
pub const K_SYSCALL_K_STACK_PUSH: u32 = 86;
pub const K_SYSCALL_K_STR_OUT: u32 = 87;
pub const K_SYSCALL_K_THREAD_ABORT: u32 = 88;
pub const K_SYSCALL_K_THREAD_CREATE: u32 = 89;
pub const K_SYSCALL_K_THREAD_CUSTOM_DATA_GET: u32 = 90;
pub const K_SYSCALL_K_THREAD_CUSTOM_DATA_SET: u32 = 91;
pub const K_SYSCALL_K_THREAD_DEADLINE_SET: u32 = 92;
pub const K_SYSCALL_K_THREAD_NAME_GET: u32 = 93;
pub const K_SYSCALL_K_THREAD_NAME_SET: u32 = 94;
pub const K_SYSCALL_K_THREAD_PRIORITY_GET: u32 = 95;
pub const K_SYSCALL_K_THREAD_PRIORITY_SET: u32 = 96;
pub const K_SYSCALL_K_THREAD_RESUME: u32 = 97;
pub const K_SYSCALL_K_THREAD_START: u32 = 98;
pub const K_SYSCALL_K_THREAD_SUSPEND: u32 = 99;
pub const K_SYSCALL_K_TIMER_REMAINING_GET: u32 = 100;
pub const K_SYSCALL_K_TIMER_START: u32 = 101;
pub const K_SYSCALL_K_TIMER_STATUS_GET: u32 = 102;
pub const K_SYSCALL_K_TIMER_STATUS_SYNC: u32 = 103;
pub const K_SYSCALL_K_TIMER_STOP: u32 = 104;
pub const K_SYSCALL_K_TIMER_USER_DATA_GET: u32 = 105;
pub const K_SYSCALL_K_TIMER_USER_DATA_SET: u32 = 106;
pub const K_SYSCALL_K_UPTIME_GET: u32 = 107;
pub const K_SYSCALL_K_UPTIME_GET_32: u32 = 108;
pub const K_SYSCALL_K_WAKEUP: u32 = 109;
pub const K_SYSCALL_K_YIELD: u32 = 110;
pub const K_SYSCALL_LED_BLINK: u32 = 111;
pub const K_SYSCALL_LED_OFF: u32 = 112;
pub const K_SYSCALL_LED_ON: u32 = 113;
pub const K_SYSCALL_LED_SET_BRIGHTNESS: u32 = 114;
pub const K_SYSCALL_PWM_GET_CYCLES_PER_SEC: u32 = 115;
pub const K_SYSCALL_PWM_PIN_SET_CYCLES: u32 = 116;
pub const K_SYSCALL_RTC_DISABLE: u32 = 117;
pub const K_SYSCALL_RTC_ENABLE: u32 = 118;
pub const K_SYSCALL_RTC_GET_PENDING_INT: u32 = 119;
pub const K_SYSCALL_RTC_READ: u32 = 120;
pub const K_SYSCALL_RTC_SET_ALARM: u32 = 121;
pub const K_SYSCALL_SENSOR_ATTR_SET: u32 = 122;
pub const K_SYSCALL_SENSOR_CHANNEL_GET: u32 = 123;
pub const K_SYSCALL_SENSOR_SAMPLE_FETCH: u32 = 124;
pub const K_SYSCALL_SENSOR_SAMPLE_FETCH_CHAN: u32 = 125;
pub const K_SYSCALL_SPI_RELEASE: u32 = 126;
pub const K_SYSCALL_SPI_TRANSCEIVE: u32 = 127;
pub const K_SYSCALL_UART_CONFIGURE: u32 = 128;
pub const K_SYSCALL_UART_CONFIG_GET: u32 = 129;
pub const K_SYSCALL_UART_DRV_CMD: u32 = 130;
pub const K_SYSCALL_UART_ERR_CHECK: u32 = 131;
pub const K_SYSCALL_UART_IRQ_ERR_DISABLE: u32 = 132;
pub const K_SYSCALL_UART_IRQ_ERR_ENABLE: u32 = 133;
pub const K_SYSCALL_UART_IRQ_IS_PENDING: u32 = 134;
pub const K_SYSCALL_UART_IRQ_RX_DISABLE: u32 = 135;
pub const K_SYSCALL_UART_IRQ_RX_ENABLE: u32 = 136;
pub const K_SYSCALL_UART_IRQ_TX_DISABLE: u32 = 137;
pub const K_SYSCALL_UART_IRQ_TX_ENABLE: u32 = 138;
pub const K_SYSCALL_UART_IRQ_UPDATE: u32 = 139;
pub const K_SYSCALL_UART_LINE_CTRL_GET: u32 = 140;
pub const K_SYSCALL_UART_LINE_CTRL_SET: u32 = 141;
pub const K_SYSCALL_UART_POLL_IN: u32 = 142;
pub const K_SYSCALL_UART_POLL_OUT: u32 = 143;
pub const K_SYSCALL_ZSOCK_ACCEPT: u32 = 144;
pub const K_SYSCALL_ZSOCK_BIND: u32 = 145;
pub const K_SYSCALL_ZSOCK_CLOSE: u32 = 146;
pub const K_SYSCALL_ZSOCK_CONNECT: u32 = 147;
pub const K_SYSCALL_ZSOCK_FCNTL: u32 = 148;
pub const K_SYSCALL_ZSOCK_INET_PTON: u32 = 149;
pub const K_SYSCALL_ZSOCK_LISTEN: u32 = 150;
pub const K_SYSCALL_ZSOCK_POLL: u32 = 151;
pub const K_SYSCALL_ZSOCK_RECVFROM: u32 = 152;
pub const K_SYSCALL_ZSOCK_SENDTO: u32 = 153;
pub const K_SYSCALL_ZSOCK_SOCKET: u32 = 154;
pub const K_SYSCALL_Z_ERRNO: u32 = 155;
pub const K_SYSCALL_Z_ZSOCK_GETADDRINFO_INTERNAL: u32 = 156;
pub const K_SYSCALL__ZEPHYR_FPUTC: u32 = 157;
pub const K_SYSCALL__ZEPHYR_FWRITE: u32 = 158;
pub const K_SYSCALL__ZEPHYR_READ: u32 = 159;
pub const K_SYSCALL__ZEPHYR_WRITE: u32 = 160;
pub const K_SYSCALL_BAD: u32 = 161;
pub const K_SYSCALL_LIMIT: u32 = 162;
pub const _SVC_CALL_IRQ_OFFLOAD: u32 = 1;
pub const _SVC_CALL_RUNTIME_EXCEPT: u32 = 2;
pub const _SVC_CALL_SYSTEM_CALL: u32 = 3;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 3usize] = b"ll\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 4usize] = b"lld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 4usize] = b"lli\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 4usize] = b"llo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 4usize] = b"llu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 4usize] = b"llx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 4usize] = b"llX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdMAX: &'static [u8; 4usize] = b"lld\0";
pub const PRIiMAX: &'static [u8; 4usize] = b"lli\0";
pub const PRIoMAX: &'static [u8; 4usize] = b"llo\0";
pub const PRIuMAX: &'static [u8; 4usize] = b"llu\0";
pub const PRIxMAX: &'static [u8; 4usize] = b"llx\0";
pub const PRIXMAX: &'static [u8; 4usize] = b"llX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 4usize] = b"lld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 4usize] = b"lli\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 4usize] = b"llu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 4usize] = b"llo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 4usize] = b"llx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdMAX: &'static [u8; 4usize] = b"lld\0";
pub const SCNiMAX: &'static [u8; 4usize] = b"lli\0";
pub const SCNoMAX: &'static [u8; 4usize] = b"llo\0";
pub const SCNuMAX: &'static [u8; 4usize] = b"llu\0";
pub const SCNxMAX: &'static [u8; 4usize] = b"llx\0";
pub const CONFIG_FLASH_BASE_ADDRESS: u32 = 0;
pub const CONFIG_FLASH_LOAD_OFFSET: u32 = 0;
pub const CONFIG_FLASH_LOAD_SIZE: u32 = 0;
pub const CONFIG_FLASH_SIZE: u32 = 256;
pub const CONFIG_SRAM_BASE_ADDRESS: u32 = 536870912;
pub const CONFIG_SRAM_SIZE: u32 = 64;
pub const DT_TI_STELLARIS_ETHERNET_40048000_BASE_ADDRESS: u32 = 1074036736;
pub const DT_TI_STELLARIS_ETHERNET_40048000_IRQ_0: u32 = 42;
pub const DT_TI_STELLARIS_ETHERNET_40048000_IRQ_0_PRIORITY: u32 = 0;
pub const DT_TI_STELLARIS_ETHERNET_40048000_LABEL: &'static [u8; 4usize] = b"ETH\0";
pub const DT_TI_STELLARIS_ETHERNET_40048000_LOCAL_MAC_ADDRESS_0: u32 = 0;
pub const DT_TI_STELLARIS_ETHERNET_40048000_LOCAL_MAC_ADDRESS_1: u32 = 0;
pub const DT_TI_STELLARIS_ETHERNET_40048000_LOCAL_MAC_ADDRESS_2: u32 = 94;
pub const DT_TI_STELLARIS_ETHERNET_40048000_LOCAL_MAC_ADDRESS_3: u32 = 0;
pub const DT_TI_STELLARIS_ETHERNET_40048000_LOCAL_MAC_ADDRESS_4: u32 = 83;
pub const DT_TI_STELLARIS_ETHERNET_40048000_LOCAL_MAC_ADDRESS_5: u32 = 0;
pub const DT_TI_STELLARIS_ETHERNET_40048000_SIZE: u32 = 60;
pub const DT_ARM_V7M_NVIC_E000E100_ARM_NUM_IRQ_PRIORITY_BITS: u32 = 3;
pub const DT_ARM_V7M_NVIC_E000E100_BASE_ADDRESS: u32 = 3758153984;
pub const DT_ARM_V7M_NVIC_E000E100_SIZE: u32 = 3072;
pub const CONFIG_UART_CONSOLE_ON_DEV_NAME: &'static [u8; 7usize] = b"UART_0\0";
pub const DT_RUST_SIMPLE_UART_4000C000_BASE_ADDRESS: u32 = 1073790976;
pub const DT_RUST_SIMPLE_UART_4000C000_CURRENT_SPEED: u32 = 115200;
pub const DT_RUST_SIMPLE_UART_4000C000_IRQ_0: u32 = 5;
pub const DT_RUST_SIMPLE_UART_4000C000_IRQ_0_PRIORITY: u32 = 3;
pub const DT_RUST_SIMPLE_UART_4000C000_LABEL: &'static [u8; 7usize] = b"UART_0\0";
pub const DT_RUST_SIMPLE_UART_4000C000_SIZE: u32 = 76;
pub const DT_RUST_SIMPLE_UART_UART_0_BASE_ADDRESS: u32 = 1073790976;
pub const DT_RUST_SIMPLE_UART_UART_0_CURRENT_SPEED: u32 = 115200;
pub const DT_RUST_SIMPLE_UART_UART_0_IRQ: u32 = 5;
pub const DT_RUST_SIMPLE_UART_UART_0_IRQ_PRIORITY: u32 = 3;
pub const DT_RUST_SIMPLE_UART_UART_0_LABEL: &'static [u8; 7usize] = b"UART_0\0";
pub const DT_RUST_SIMPLE_UART_UART_0_SIZE: u32 = 76;
pub const UART_0_BASE_ADDRESS: u32 = 1073790976;
pub const UART_0_CURRENT_SPEED: u32 = 115200;
pub const UART_0_IRQ: u32 = 5;
pub const UART_0_IRQ_PRIORITY: u32 = 3;
pub const UART_0_LABEL: &'static [u8; 7usize] = b"UART_0\0";
pub const UART_0_SIZE: u32 = 76;
pub const CONFIG_UART_PIPE_ON_DEV_NAME: &'static [u8; 7usize] = b"UART_1\0";
pub const DT_TI_STELLARIS_UART_4000D000_BASE_ADDRESS: u32 = 1073795072;
pub const DT_TI_STELLARIS_UART_4000D000_CURRENT_SPEED: u32 = 115200;
pub const DT_TI_STELLARIS_UART_4000D000_IRQ_0: u32 = 6;
pub const DT_TI_STELLARIS_UART_4000D000_IRQ_0_PRIORITY: u32 = 3;
pub const DT_TI_STELLARIS_UART_4000D000_LABEL: &'static [u8; 7usize] = b"UART_1\0";
pub const DT_TI_STELLARIS_UART_4000D000_SIZE: u32 = 76;
pub const DT_TI_STELLARIS_UART_UART_1_BASE_ADDRESS: u32 = 1073795072;
pub const DT_TI_STELLARIS_UART_UART_1_CURRENT_SPEED: u32 = 115200;
pub const DT_TI_STELLARIS_UART_UART_1_IRQ: u32 = 6;
pub const DT_TI_STELLARIS_UART_UART_1_IRQ_PRIORITY: u32 = 3;
pub const DT_TI_STELLARIS_UART_UART_1_LABEL: &'static [u8; 7usize] = b"UART_1\0";
pub const DT_TI_STELLARIS_UART_UART_1_SIZE: u32 = 76;
pub const UART_1_BASE_ADDRESS: u32 = 1073795072;
pub const UART_1_CURRENT_SPEED: u32 = 115200;
pub const UART_1_IRQ: u32 = 6;
pub const UART_1_IRQ_PRIORITY: u32 = 3;
pub const UART_1_LABEL: &'static [u8; 7usize] = b"UART_1\0";
pub const UART_1_SIZE: u32 = 76;
pub const CONFIG_BT_MONITOR_ON_DEV_NAME: &'static [u8; 7usize] = b"UART_2\0";
pub const CONFIG_BT_UART_ON_DEV_NAME: &'static [u8; 7usize] = b"UART_2\0";
pub const DT_TI_STELLARIS_UART_4000E000_BASE_ADDRESS: u32 = 1073799168;
pub const DT_TI_STELLARIS_UART_4000E000_CURRENT_SPEED: u32 = 115200;
pub const DT_TI_STELLARIS_UART_4000E000_IRQ_0: u32 = 33;
pub const DT_TI_STELLARIS_UART_4000E000_IRQ_0_PRIORITY: u32 = 3;
pub const DT_TI_STELLARIS_UART_4000E000_LABEL: &'static [u8; 7usize] = b"UART_2\0";
pub const DT_TI_STELLARIS_UART_4000E000_SIZE: u32 = 76;
pub const DT_TI_STELLARIS_UART_UART_2_BASE_ADDRESS: u32 = 1073799168;
pub const DT_TI_STELLARIS_UART_UART_2_CURRENT_SPEED: u32 = 115200;
pub const DT_TI_STELLARIS_UART_UART_2_IRQ: u32 = 33;
pub const DT_TI_STELLARIS_UART_UART_2_IRQ_PRIORITY: u32 = 3;
pub const DT_TI_STELLARIS_UART_UART_2_LABEL: &'static [u8; 7usize] = b"UART_2\0";
pub const DT_TI_STELLARIS_UART_UART_2_SIZE: u32 = 76;
pub const UART_2_BASE_ADDRESS: u32 = 1073799168;
pub const UART_2_CURRENT_SPEED: u32 = 115200;
pub const UART_2_IRQ: u32 = 33;
pub const UART_2_IRQ_PRIORITY: u32 = 3;
pub const UART_2_LABEL: &'static [u8; 7usize] = b"UART_2\0";
pub const UART_2_SIZE: u32 = 76;
pub const DT_COMPAT_ARM_V7M_NVIC: u32 = 1;
pub const DT_COMPAT_RUST_SIMPLE_UART: u32 = 1;
pub const DT_COMPAT_SOC_NV_FLASH: u32 = 1;
pub const DT_COMPAT_TI_STELLARIS_UART: u32 = 1;
pub const DT_NUM_IRQ_PRIO_BITS: u32 = 3;
pub const DT_ETH_BASE_ADDR: u32 = 1074036736;
pub const DT_ETH_DRV_NAME: &'static [u8; 4usize] = b"ETH\0";
pub const DT_ETH_IRQ: u32 = 42;
pub const DT_ETH_IRQ_PRIO: u32 = 0;
pub const DT_ETH_MAC_ADDR_0: u32 = 0;
pub const DT_ETH_MAC_ADDR_1: u32 = 0;
pub const DT_ETH_MAC_ADDR_2: u32 = 94;
pub const DT_ETH_MAC_ADDR_3: u32 = 0;
pub const DT_ETH_MAC_ADDR_4: u32 = 83;
pub const DT_ETH_MAC_ADDR_5: u32 = 0;
pub const _EXCEPTION_RESERVED_PRIO: u32 = 1;
pub const _EXC_FAULT_PRIO: u32 = 0;
pub const _EXC_SVC_PRIO: u32 = 0;
pub const _IRQ_PRIO_OFFSET: u32 = 1;
pub const ISR_FLAG_DIRECT: u32 = 1;
pub const IRQ_TABLE_SIZE: u32 = 43;
pub const _NANO_ERR_HW_EXCEPTION: u32 = 0;
pub const _NANO_ERR_STACK_CHK_FAIL: u32 = 2;
pub const _NANO_ERR_ALLOCATION_FAIL: u32 = 3;
pub const _NANO_ERR_KERNEL_OOPS: u32 = 4;
pub const _NANO_ERR_KERNEL_PANIC: u32 = 5;
pub const _NANO_ERR_RECOVERABLE: u32 = 6;
pub const _CODE_BASE_ADDR: u32 = 0;
pub const _CODE_END_ADDR: u32 = 536870911;
pub const _SRAM_BASE_ADDR: u32 = 536870912;
pub const _SRAM_BIT_BAND_REGION: u32 = 536870912;
pub const _SRAM_BIT_BAND_REGION_END: u32 = 537919487;
pub const _SRAM_BIT_BAND_ALIAS: u32 = 570425344;
pub const _SRAM_BIT_BAND_ALIAS_END: u32 = 603979775;
pub const _SRAM_END_ADDR: u32 = 1073741823;
pub const _PERI_BASE_ADDR: u32 = 1073741824;
pub const _PERI_BIT_BAND_REGION: u32 = 1073741824;
pub const _PERI_BIT_BAND_REGION_END: u32 = 1074790399;
pub const _PERI_BIT_BAND_ALIAS: u32 = 1107296256;
pub const _PERI_BIT_BAND_ALIAS_END: u32 = 1140850687;
pub const _PERI_END_ADDR: u32 = 1610612735;
pub const _ERAM_BASE_ADDR: u32 = 1610612736;
pub const _ERAM_END_ADDR: u32 = 2684354559;
pub const _EDEV_BASE_ADDR: u32 = 2684354560;
pub const _EDEV_END_ADDR: u32 = 3758096383;
pub const _PPB_INT_BASE_ADDR: u32 = 3758096384;
pub const _PPB_INT_ITM: u32 = 3758096384;
pub const _PPB_INT_DWT: u32 = 3758100480;
pub const _PPB_INT_FPB: u32 = 3758104576;
pub const _PPB_INT_RSVD_1: u32 = 3758108672;
pub const _PPB_INT_SCS: u32 = 3758153728;
pub const _PPB_INT_RSVD_2: u32 = 3758157824;
pub const _PPB_INT_END_ADDR: u32 = 3758358527;
pub const _PPB_EXT_BASE_ADDR: u32 = 3758358528;
pub const _PPB_EXT_TPIU: u32 = 3758358528;
pub const _PPB_EXT_ETM: u32 = 3758362624;
pub const _PPB_EXT_PPB: u32 = 3758366720;
pub const _PPB_EXT_ROM_TABLE: u32 = 3759140864;
pub const _PPB_EXT_END_ADDR: u32 = 3759144959;
pub const _VENDOR_BASE_ADDR: u32 = 3759144960;
pub const _VENDOR_END_ADDR: u32 = 4294967295;
pub const STACK_ALIGN_SIZE: u32 = 8;
pub const MPU_GUARD_ALIGN_AND_SIZE: u32 = 0;
pub const NSEC_PER_USEC: u32 = 1000;
pub const USEC_PER_MSEC: u32 = 1000;
pub const MSEC_PER_SEC: u32 = 1000;
pub const USEC_PER_SEC: u32 = 1000000;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const _TICK_ALIGN: u32 = 1;
pub const _NUM_COOP_PRIO: u32 = 16;
pub const _NUM_PREEMPT_PRIO: u32 = 16;
pub const K_HIGHEST_THREAD_PRIO: i32 = -16;
pub const K_LOWEST_THREAD_PRIO: u32 = 15;
pub const K_IDLE_PRIO: u32 = 15;
pub const K_HIGHEST_APPLICATION_THREAD_PRIO: i32 = -16;
pub const K_LOWEST_APPLICATION_THREAD_PRIO: u32 = 14;
pub const _EXPIRED: i32 = -2;
pub const _INACTIVE: i32 = -1;
pub const K_NO_WAIT: u32 = 0;
pub const K_FOREVER: i32 = -1;
pub const K_POLL_TYPE_IGNORE: u32 = 0;
pub const K_POLL_STATE_NOT_READY: u32 = 0;
pub const SYS_TRACE_ID_OFFSET: u32 = 32;
pub const SYS_TRACE_ID_MUTEX_INIT: u32 = 33;
pub const SYS_TRACE_ID_MUTEX_UNLOCK: u32 = 34;
pub const SYS_TRACE_ID_MUTEX_LOCK: u32 = 35;
pub const SYS_TRACE_ID_SEMA_INIT: u32 = 36;
pub const SYS_TRACE_ID_SEMA_GIVE: u32 = 37;
pub const SYS_TRACE_ID_SEMA_TAKE: u32 = 38;
pub const Z_DEVICE_MAX_NAME_LEN: u32 = 48;
pub const UART_OPTION_AFCE: u32 = 1;
pub const LINE_CTRL_BAUD_RATE: u32 = 1;
pub const LINE_CTRL_RTS: u32 = 2;
pub const LINE_CTRL_DTR: u32 = 4;
pub const LINE_CTRL_DCD: u32 = 8;
pub const LINE_CTRL_DSR: u32 = 16;
pub const UART_ERROR_OVERRUN: u32 = 1;
pub const UART_ERROR_PARITY: u32 = 2;
pub const UART_ERROR_FRAMING: u32 = 4;
pub const UART_ERROR_BREAK: u32 = 8;
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __quad_t = cty::c_longlong;
pub type __u_quad_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __dev_t = __u_quad_t;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = __u_quad_t;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_uint;
pub type __off_t = cty::c_long;
pub type __off64_t = __quad_t;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = __u_quad_t;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = __quad_t;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = __u_quad_t;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = __u_quad_t;
pub type __fsword_t = cty::c_int;
pub type __ssize_t = cty::c_int;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_int;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: cty::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: cty::c_uint,
    pub __wchb: [cty::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        12usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: cty::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::core::mem::size_of::<_IO_marker>(),
        12usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_marker>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: cty::c_int,
    pub _IO_read_ptr: *mut cty::c_char,
    pub _IO_read_end: *mut cty::c_char,
    pub _IO_read_base: *mut cty::c_char,
    pub _IO_write_base: *mut cty::c_char,
    pub _IO_write_ptr: *mut cty::c_char,
    pub _IO_write_end: *mut cty::c_char,
    pub _IO_buf_base: *mut cty::c_char,
    pub _IO_buf_end: *mut cty::c_char,
    pub _IO_save_base: *mut cty::c_char,
    pub _IO_backup_base: *mut cty::c_char,
    pub _IO_save_end: *mut cty::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: cty::c_int,
    pub _flags2: cty::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: cty::c_ushort,
    pub _vtable_offset: cty::c_schar,
    pub _shortbuf: [cty::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut cty::c_void,
    pub __pad2: *mut cty::c_void,
    pub __pad3: *mut cty::c_void,
    pub __pad4: *mut cty::c_void,
    pub __pad5: usize,
    pub _mode: cty::c_int,
    pub _unused2: [cty::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        148usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut cty::c_void,
        __buf: *mut cty::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut cty::c_void,
        __buf: *const cty::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut cty::c_void,
        __pos: *mut __off64_t,
        __w: cty::c_int,
    ) -> cty::c_int,
>;
pub type __io_close_fn =
    ::core::option::Option<unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> cty::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> cty::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> cty::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: cty::c_int, __fp: *mut _IO_FILE) -> cty::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> cty::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> cty::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> cty::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> cty::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
        arg4: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: cty::c_int, arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut cty::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: cty::c_int,
        arg4: cty::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t, arg3: cty::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rename(__old: *const cty::c_char, __new: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: cty::c_int,
        __old: *const cty::c_char,
        __newfd: cty::c_int,
        __new: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const cty::c_char, __pfx: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const cty::c_char, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const cty::c_char,
        __modes: *const cty::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: cty::c_int, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut cty::c_void, __len: usize, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut cty::c_char, __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut cty::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut cty::c_char,
        __modes: cty::c_int,
        __n: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut cty::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn printf(__format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut cty::c_char, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const cty::c_char,
        __arg: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const cty::c_char, __arg: __builtin_va_list) -> cty::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut cty::c_char,
        __format: *const cty::c_char,
        __arg: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut cty::c_char,
        __maxlen: cty::c_uint,
        __format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut cty::c_char,
        __maxlen: cty::c_uint,
        __format: *const cty::c_char,
        __arg: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: cty::c_int,
        __fmt: *const cty::c_char,
        __arg: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn dprintf(__fd: cty::c_int, __fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn scanf(__format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const cty::c_char, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(__s: *const cty::c_char, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const cty::c_char,
        __arg: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const cty::c_char, __arg: __builtin_va_list) -> cty::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const cty::c_char,
        __format: *const cty::c_char,
        __arg: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const cty::c_char,
        __arg: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const cty::c_char, __arg: __builtin_va_list) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const cty::c_char,
        __format: *const cty::c_char,
        __arg: __builtin_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar() -> cty::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> cty::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putw(__w: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut cty::c_char, __n: cty::c_int, __stream: *mut FILE) -> *mut cty::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut cty::c_char,
        __n: *mut usize,
        __delimiter: cty::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut cty::c_char,
        __n: *mut usize,
        __delimiter: cty::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut cty::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const cty::c_char, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn puts(__s: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn ungetc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut cty::c_void,
        __size: cty::c_uint,
        __n: cty::c_uint,
        __stream: *mut FILE,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const cty::c_void,
        __size: cty::c_uint,
        __n: cty::c_uint,
        __s: *mut FILE,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut cty::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const cty::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: cty::c_long, __whence: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn perror(__s: *const cty::c_char);
}
extern "C" {
    #[link_name = "\u{1}sys_nerr"]
    pub static mut sys_nerr: cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}sys_errlist"]
    pub static mut sys_errlist: [*const cty::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn popen(__command: *const cty::c_char, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __errno_location() -> *mut cty::c_int;
}
pub type wchar_t = cty::c_int;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        24usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = cty::c_schar;
pub type int_least16_t = cty::c_short;
pub type int_least32_t = cty::c_int;
pub type int_least64_t = cty::c_longlong;
pub type uint_least8_t = cty::c_uchar;
pub type uint_least16_t = cty::c_ushort;
pub type uint_least32_t = cty::c_uint;
pub type uint_least64_t = cty::c_ulonglong;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_int;
pub type int_fast32_t = cty::c_int;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_uint;
pub type uint_fast32_t = cty::c_uint;
pub type uint_fast64_t = cty::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type s8_t = cty::c_schar;
pub type s16_t = cty::c_short;
pub type s32_t = cty::c_int;
pub type s64_t = cty::c_longlong;
pub type u8_t = cty::c_uchar;
pub type u16_t = cty::c_ushort;
pub type u32_t = cty::c_uint;
pub type u64_t = cty::c_ulonglong;
pub type atomic_t = cty::c_int;
pub type atomic_val_t = atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _dnode {
    pub __bindgen_anon_1: _dnode__bindgen_ty_1,
    pub __bindgen_anon_2: _dnode__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _dnode__bindgen_ty_1 {
    pub head: *mut _dnode,
    pub next: *mut _dnode,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__dnode__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_dnode__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_dnode__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_dnode__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_dnode__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_dnode__bindgen_ty_1>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_dnode__bindgen_ty_1),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_dnode__bindgen_ty_1>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_dnode__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _dnode__bindgen_ty_2 {
    pub tail: *mut _dnode,
    pub prev: *mut _dnode,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__dnode__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_dnode__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(_dnode__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_dnode__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_dnode__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_dnode__bindgen_ty_2>())).tail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_dnode__bindgen_ty_2),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_dnode__bindgen_ty_2>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_dnode__bindgen_ty_2),
            "::",
            stringify!(prev)
        )
    );
}
#[test]
fn bindgen_test_layout__dnode() {
    assert_eq!(
        ::core::mem::size_of::<_dnode>(),
        8usize,
        concat!("Size of: ", stringify!(_dnode))
    );
    assert_eq!(
        ::core::mem::align_of::<_dnode>(),
        4usize,
        concat!("Alignment of ", stringify!(_dnode))
    );
}
pub type sys_dlist_t = _dnode;
pub type sys_dnode_t = _dnode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rbnode {
    pub children: [*mut rbnode; 2usize],
}
#[test]
fn bindgen_test_layout_rbnode() {
    assert_eq!(
        ::core::mem::size_of::<rbnode>(),
        8usize,
        concat!("Size of: ", stringify!(rbnode))
    );
    assert_eq!(
        ::core::mem::align_of::<rbnode>(),
        4usize,
        concat!("Alignment of ", stringify!(rbnode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rbnode>())).children as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rbnode),
            "::",
            stringify!(children)
        )
    );
}
#[doc = " @typedef rb_lessthan_t"]
#[doc = " @brief Red/black tree comparison predicate"]
#[doc = ""]
#[doc = " Compares the two nodes and returns true if node A is strictly less"]
#[doc = " than B according to the tree\'s sorting criteria, false otherwise."]
#[doc = ""]
#[doc = " Note that during insert, the new node being inserted will always be"]
#[doc = " \"A\", where \"B\" is the existing node within the tree against which"]
#[doc = " it is being compared.  This trait can be used (with care!) to"]
#[doc = " implement \"most/least recently added\" semantics between nodes which"]
#[doc = " would otherwise compare as equal."]
pub type rb_lessthan_t =
    ::core::option::Option<unsafe extern "C" fn(a: *mut rbnode, b: *mut rbnode) -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rbtree {
    pub root: *mut rbnode,
    pub lessthan_fn: rb_lessthan_t,
    pub max_depth: cty::c_int,
}
#[test]
fn bindgen_test_layout_rbtree() {
    assert_eq!(
        ::core::mem::size_of::<rbtree>(),
        12usize,
        concat!("Size of: ", stringify!(rbtree))
    );
    assert_eq!(
        ::core::mem::align_of::<rbtree>(),
        4usize,
        concat!("Alignment of ", stringify!(rbtree))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rbtree>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rbtree),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rbtree>())).lessthan_fn as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rbtree),
            "::",
            stringify!(lessthan_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rbtree>())).max_depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rbtree),
            "::",
            stringify!(max_depth)
        )
    );
}
pub type rb_visit_t =
    ::core::option::Option<unsafe extern "C" fn(node: *mut rbnode, cookie: *mut cty::c_void)>;
extern "C" {
    pub fn _rb_child(node: *mut rbnode, side: cty::c_int) -> *mut rbnode;
}
extern "C" {
    pub fn _rb_is_black(node: *mut rbnode) -> cty::c_int;
}
extern "C" {
    pub fn _rb_walk(node: *mut rbnode, visit_fn: rb_visit_t, cookie: *mut cty::c_void);
}
extern "C" {
    pub fn _rb_get_minmax(tree: *mut rbtree, side: cty::c_int) -> *mut rbnode;
}
extern "C" {
    #[doc = " @brief Insert node into tree"]
    pub fn rb_insert(tree: *mut rbtree, node: *mut rbnode);
}
extern "C" {
    #[doc = " @brief Remove node from tree"]
    pub fn rb_remove(tree: *mut rbtree, node: *mut rbnode);
}
extern "C" {
    #[doc = " @brief Returns true if the given node is part of the tree"]
    #[doc = ""]
    #[doc = " Note that this does not internally dereference the node pointer"]
    #[doc = " (though the tree\'s lessthan callback might!), it just tests it for"]
    #[doc = " equality with items in the tree.  So it\'s feasible to use this to"]
    #[doc = " implement a \"set\" construct by simply testing the pointer value"]
    #[doc = " itself."]
    pub fn rb_contains(tree: *mut rbtree, node: *mut rbnode) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rb_foreach {
    pub stack: *mut *mut rbnode,
    pub is_left: *mut cty::c_char,
    pub top: cty::c_int,
}
#[test]
fn bindgen_test_layout__rb_foreach() {
    assert_eq!(
        ::core::mem::size_of::<_rb_foreach>(),
        12usize,
        concat!("Size of: ", stringify!(_rb_foreach))
    );
    assert_eq!(
        ::core::mem::align_of::<_rb_foreach>(),
        4usize,
        concat!("Alignment of ", stringify!(_rb_foreach))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rb_foreach>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rb_foreach),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rb_foreach>())).is_left as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_rb_foreach),
            "::",
            stringify!(is_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rb_foreach>())).top as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_rb_foreach),
            "::",
            stringify!(top)
        )
    );
}
extern "C" {
    pub fn _rb_foreach_next(tree: *mut rbtree, f: *mut _rb_foreach) -> *mut rbnode;
}
extern "C" {
    pub fn _priq_dumb_best(pq: *mut sys_dlist_t) -> *mut k_thread;
}
extern "C" {
    pub fn _priq_dumb_remove(pq: *mut sys_dlist_t, thread: *mut k_thread);
}
extern "C" {
    pub fn _priq_dumb_add(pq: *mut sys_dlist_t, thread: *mut k_thread);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _priq_rb {
    pub tree: rbtree,
    pub next_order_key: cty::c_int,
}
#[test]
fn bindgen_test_layout__priq_rb() {
    assert_eq!(
        ::core::mem::size_of::<_priq_rb>(),
        16usize,
        concat!("Size of: ", stringify!(_priq_rb))
    );
    assert_eq!(
        ::core::mem::align_of::<_priq_rb>(),
        4usize,
        concat!("Alignment of ", stringify!(_priq_rb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_priq_rb>())).tree as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_priq_rb),
            "::",
            stringify!(tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_priq_rb>())).next_order_key as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_priq_rb),
            "::",
            stringify!(next_order_key)
        )
    );
}
extern "C" {
    pub fn _priq_rb_add(pq: *mut _priq_rb, thread: *mut k_thread);
}
extern "C" {
    pub fn _priq_rb_remove(pq: *mut _priq_rb, thread: *mut k_thread);
}
extern "C" {
    pub fn _priq_rb_best(pq: *mut _priq_rb) -> *mut k_thread;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _priq_mq {
    pub queues: [sys_dlist_t; 32usize],
    pub bitmask: cty::c_uint,
}
#[test]
fn bindgen_test_layout__priq_mq() {
    assert_eq!(
        ::core::mem::size_of::<_priq_mq>(),
        260usize,
        concat!("Size of: ", stringify!(_priq_mq))
    );
    assert_eq!(
        ::core::mem::align_of::<_priq_mq>(),
        4usize,
        concat!("Alignment of ", stringify!(_priq_mq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_priq_mq>())).queues as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_priq_mq),
            "::",
            stringify!(queues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_priq_mq>())).bitmask as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_priq_mq),
            "::",
            stringify!(bitmask)
        )
    );
}
extern "C" {
    pub fn _priq_mq_add(pq: *mut _priq_mq, thread: *mut k_thread);
}
extern "C" {
    pub fn _priq_mq_remove(pq: *mut _priq_mq, thread: *mut k_thread);
}
extern "C" {
    pub fn _priq_mq_best(pq: *mut _priq_mq) -> *mut k_thread;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _snode {
    pub next: *mut _snode,
}
#[test]
fn bindgen_test_layout__snode() {
    assert_eq!(
        ::core::mem::size_of::<_snode>(),
        4usize,
        concat!("Size of: ", stringify!(_snode))
    );
    assert_eq!(
        ::core::mem::align_of::<_snode>(),
        4usize,
        concat!("Alignment of ", stringify!(_snode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_snode>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_snode),
            "::",
            stringify!(next)
        )
    );
}
pub type sys_snode_t = _snode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _slist {
    pub head: *mut sys_snode_t,
    pub tail: *mut sys_snode_t,
}
#[test]
fn bindgen_test_layout__slist() {
    assert_eq!(
        ::core::mem::size_of::<_slist>(),
        8usize,
        concat!("Size of: ", stringify!(_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<_slist>(),
        4usize,
        concat!("Alignment of ", stringify!(_slist))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_slist>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_slist),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_slist>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_slist),
            "::",
            stringify!(tail)
        )
    );
}
pub type sys_slist_t = _slist;
pub type unative_t = u32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _sfnode {
    pub next_and_flags: unative_t,
}
#[test]
fn bindgen_test_layout__sfnode() {
    assert_eq!(
        ::core::mem::size_of::<_sfnode>(),
        4usize,
        concat!("Size of: ", stringify!(_sfnode))
    );
    assert_eq!(
        ::core::mem::align_of::<_sfnode>(),
        4usize,
        concat!("Alignment of ", stringify!(_sfnode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sfnode>())).next_and_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sfnode),
            "::",
            stringify!(next_and_flags)
        )
    );
}
pub type sys_sfnode_t = _sfnode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _sflist {
    pub head: *mut sys_sfnode_t,
    pub tail: *mut sys_sfnode_t,
}
#[test]
fn bindgen_test_layout__sflist() {
    assert_eq!(
        ::core::mem::size_of::<_sflist>(),
        8usize,
        concat!("Size of: ", stringify!(_sflist))
    );
    assert_eq!(
        ::core::mem::align_of::<_sflist>(),
        4usize,
        concat!("Alignment of ", stringify!(_sflist))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sflist>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sflist),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sflist>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_sflist),
            "::",
            stringify!(tail)
        )
    );
}
pub type sys_sflist_t = _sflist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sys_mem_pool_lvl {
    pub __bindgen_anon_1: sys_mem_pool_lvl__bindgen_ty_1,
    pub free_list: sys_dlist_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sys_mem_pool_lvl__bindgen_ty_1 {
    pub bits_p: *mut u32_t,
    pub bits: u32_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sys_mem_pool_lvl__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sys_mem_pool_lvl__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sys_mem_pool_lvl__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sys_mem_pool_lvl__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sys_mem_pool_lvl__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sys_mem_pool_lvl__bindgen_ty_1>())).bits_p as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_mem_pool_lvl__bindgen_ty_1),
            "::",
            stringify!(bits_p)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sys_mem_pool_lvl__bindgen_ty_1>())).bits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_mem_pool_lvl__bindgen_ty_1),
            "::",
            stringify!(bits)
        )
    );
}
#[test]
fn bindgen_test_layout_sys_mem_pool_lvl() {
    assert_eq!(
        ::core::mem::size_of::<sys_mem_pool_lvl>(),
        12usize,
        concat!("Size of: ", stringify!(sys_mem_pool_lvl))
    );
    assert_eq!(
        ::core::mem::align_of::<sys_mem_pool_lvl>(),
        4usize,
        concat!("Alignment of ", stringify!(sys_mem_pool_lvl))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_mem_pool_lvl>())).free_list as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_mem_pool_lvl),
            "::",
            stringify!(free_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_mem_pool_base {
    pub buf: *mut cty::c_void,
    pub max_sz: usize,
    pub n_max: u16_t,
    pub n_levels: u8_t,
    pub max_inline_level: s8_t,
    pub levels: *mut sys_mem_pool_lvl,
    pub flags: u8_t,
}
#[test]
fn bindgen_test_layout_sys_mem_pool_base() {
    assert_eq!(
        ::core::mem::size_of::<sys_mem_pool_base>(),
        20usize,
        concat!("Size of: ", stringify!(sys_mem_pool_base))
    );
    assert_eq!(
        ::core::mem::align_of::<sys_mem_pool_base>(),
        4usize,
        concat!("Alignment of ", stringify!(sys_mem_pool_base))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_mem_pool_base>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_mem_pool_base),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_mem_pool_base>())).max_sz as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_mem_pool_base),
            "::",
            stringify!(max_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_mem_pool_base>())).n_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_mem_pool_base),
            "::",
            stringify!(n_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_mem_pool_base>())).n_levels as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_mem_pool_base),
            "::",
            stringify!(n_levels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sys_mem_pool_base>())).max_inline_level as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_mem_pool_base),
            "::",
            stringify!(max_inline_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_mem_pool_base>())).levels as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_mem_pool_base),
            "::",
            stringify!(levels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sys_mem_pool_base>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_mem_pool_base),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn _sys_mem_pool_base_init(p: *mut sys_mem_pool_base);
}
extern "C" {
    pub fn _sys_mem_pool_block_alloc(
        p: *mut sys_mem_pool_base,
        size: usize,
        level_p: *mut u32_t,
        block_p: *mut u32_t,
        data_p: *mut *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sys_mem_pool_block_free(p: *mut sys_mem_pool_base, level: u32_t, block: u32_t);
}
extern "C" {
    pub fn sys_kernel_version_get() -> u32_t;
}
extern "C" {
    pub fn sys_rand32_get() -> u32_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _caller_saved {}
#[test]
fn bindgen_test_layout__caller_saved() {
    assert_eq!(
        ::core::mem::size_of::<_caller_saved>(),
        0usize,
        concat!("Size of: ", stringify!(_caller_saved))
    );
    assert_eq!(
        ::core::mem::align_of::<_caller_saved>(),
        1usize,
        concat!("Alignment of ", stringify!(_caller_saved))
    );
}
pub type _caller_saved_t = _caller_saved;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _callee_saved {
    pub v1: u32_t,
    pub v2: u32_t,
    pub v3: u32_t,
    pub v4: u32_t,
    pub v5: u32_t,
    pub v6: u32_t,
    pub v7: u32_t,
    pub v8: u32_t,
    pub psp: u32_t,
}
#[test]
fn bindgen_test_layout__callee_saved() {
    assert_eq!(
        ::core::mem::size_of::<_callee_saved>(),
        36usize,
        concat!("Size of: ", stringify!(_callee_saved))
    );
    assert_eq!(
        ::core::mem::align_of::<_callee_saved>(),
        4usize,
        concat!("Alignment of ", stringify!(_callee_saved))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_callee_saved>())).v1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_callee_saved>())).v2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(v2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_callee_saved>())).v3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(v3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_callee_saved>())).v4 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(v4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_callee_saved>())).v5 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(v5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_callee_saved>())).v6 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(v6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_callee_saved>())).v7 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(v7)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_callee_saved>())).v8 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(v8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_callee_saved>())).psp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_callee_saved),
            "::",
            stringify!(psp)
        )
    );
}
pub type _callee_saved_t = _callee_saved;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _thread_arch {
    pub basepri: u32_t,
    pub swap_return_value: u32_t,
}
#[test]
fn bindgen_test_layout__thread_arch() {
    assert_eq!(
        ::core::mem::size_of::<_thread_arch>(),
        8usize,
        concat!("Size of: ", stringify!(_thread_arch))
    );
    assert_eq!(
        ::core::mem::align_of::<_thread_arch>(),
        4usize,
        concat!("Alignment of ", stringify!(_thread_arch))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_thread_arch>())).basepri as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_arch),
            "::",
            stringify!(basepri)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_thread_arch>())).swap_return_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_arch),
            "::",
            stringify!(swap_return_value)
        )
    );
}
pub type _thread_arch_t = _thread_arch;
extern "C" {
    pub fn hdlr_pwm_pin_set_cycles(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_pwm_get_cycles_per_sec(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_dma_start(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_dma_stop(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_aio_cmp_disable(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_aio_cmp_get_pending_int(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_i2s_configure(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_i2s_buf_read(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_i2s_buf_write(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_i2s_trigger(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_gpio_config(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_gpio_write(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_gpio_read(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_gpio_enable_callback(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_gpio_disable_callback(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_gpio_get_pending_int(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_device_get_binding(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_flash_read(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_flash_write(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_flash_erase(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_flash_write_protection_set(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_flash_get_page_info_by_offs(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_flash_get_page_info_by_idx(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_flash_get_page_count(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_flash_get_write_block_size(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_sensor_attr_set(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_sensor_sample_fetch(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_sensor_sample_fetch_chan(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_sensor_channel_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_rtc_read(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_rtc_enable(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_rtc_disable(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_rtc_set_alarm(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_rtc_get_pending_int(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_led_blink(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_led_set_brightness(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_led_on(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_led_off(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_can_send(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_can_attach_msgq(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_can_attach_isr(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_can_detach(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_can_configure(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_i2c_configure(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_i2c_transfer(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_i2c_slave_register(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_i2c_slave_unregister(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_i2c_slave_driver_register(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_i2c_slave_driver_unregister(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_spi_transceive(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_spi_release(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_ipm_send(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_ipm_max_data_size_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_ipm_max_id_val_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_ipm_set_enabled(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_object_access_grant(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_object_release(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_object_alloc(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_create(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_sleep(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_busy_wait(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_yield(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_wakeup(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_current_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_abort(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_start(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_priority_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_priority_set(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_deadline_set(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_suspend(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_resume(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_is_preempt_thread(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_custom_data_set(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_custom_data_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_name_set(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_thread_name_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_timer_start(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_timer_stop(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_timer_status_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_timer_status_sync(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_timer_remaining_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_timer_user_data_set(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_timer_user_data_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_uptime_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_uptime_get_32(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_queue_init(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_queue_cancel_wait(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_queue_alloc_append(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_queue_alloc_prepend(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_queue_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_queue_is_empty(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_queue_peek_head(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_queue_peek_tail(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_stack_alloc_init(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_stack_push(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_stack_pop(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_mutex_init(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_mutex_lock(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_mutex_unlock(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_sem_init(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_sem_take(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_sem_give(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_sem_reset(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_sem_count_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_alert_recv(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_alert_send(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_msgq_alloc_init(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_msgq_put(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_msgq_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_msgq_peek(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_msgq_purge(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_msgq_num_free_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_msgq_get_attrs(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_msgq_num_used_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_pipe_alloc_init(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_pipe_put(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_pipe_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_poll(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_poll_signal_init(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_poll_signal_reset(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_poll_signal_check(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_poll_signal_raise(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_k_str_out(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_err_check(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_poll_in(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_poll_out(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_configure(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_config_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_irq_tx_enable(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_irq_tx_disable(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_irq_rx_enable(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_irq_rx_disable(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_irq_err_enable(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_irq_err_disable(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_irq_is_pending(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_irq_update(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_line_ctrl_set(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_line_ctrl_get(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_uart_drv_cmd(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_entropy_get_entropy(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_counter_start(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_counter_stop(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_counter_read(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_counter_get_pending_int(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr__zephyr_read(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr__zephyr_write(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr__zephyr_fputc(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr__zephyr_fwrite(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_z_errno(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_zsock_socket(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_zsock_close(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_zsock_bind(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_zsock_connect(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_zsock_listen(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_zsock_accept(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_zsock_sendto(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_zsock_recvfrom(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_zsock_fcntl(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_zsock_poll(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_zsock_inet_pton(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn hdlr_z_zsock_getaddrinfo_internal(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t;
}
#[doc = " @typedef _k_syscall_handler_t"]
#[doc = " @brief System call handler function type"]
#[doc = ""]
#[doc = " These are kernel-side skeleton functions for system calls. They are"]
#[doc = " necessary to sanitize the arguments passed into the system call:"]
#[doc = ""]
#[doc = " - Any kernel object or device pointers are validated with _SYSCALL_IS_OBJ()"]
#[doc = " - Any memory buffers passed in are checked to ensure that the calling thread"]
#[doc = "   actually has access to them"]
#[doc = " - Many kernel calls do no sanity checking of parameters other than"]
#[doc = "   assertions. The handler must check all of these conditions using"]
#[doc = "   _SYSCALL_ASSERT()"]
#[doc = " - If the system call has more than 6 arguments, then arg6 will be a pointer"]
#[doc = "   to some struct containing arguments 6+. The struct itself needs to be"]
#[doc = "   validated like any other buffer passed in from userspace, and its members"]
#[doc = "   individually validated (if necessary) and then passed to the real"]
#[doc = "   implementation like normal arguments"]
#[doc = ""]
#[doc = " Even if the system call implementation has no return value, these always"]
#[doc = " return something, even 0, to prevent register leakage to userspace."]
#[doc = ""]
#[doc = " Once everything has been validated, the real implementation will be executed."]
#[doc = ""]
#[doc = " @param arg1 system call argument 1"]
#[doc = " @param arg2 system call argument 2"]
#[doc = " @param arg3 system call argument 3"]
#[doc = " @param arg4 system call argument 4"]
#[doc = " @param arg5 system call argument 5"]
#[doc = " @param arg6 system call argument 6"]
#[doc = " @param ssf System call stack frame pointer. Used to generate kernel oops"]
#[doc = "            via _arch_syscall_oops_at(). Contents are arch-specific."]
#[doc = " @return system call return value, or 0 if the system call implementation"]
#[doc = "         return void"]
#[doc = ""]
pub type _k_syscall_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: u32_t,
        arg2: u32_t,
        arg3: u32_t,
        arg4: u32_t,
        arg5: u32_t,
        arg6: u32_t,
        ssf: *mut cty::c_void,
    ) -> u32_t,
>;
pub type __gwchar_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: cty::c_longlong,
    pub rem: cty::c_longlong,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::core::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<imaxdiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: cty::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn printk(fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn vprintk(fmt: *const cty::c_char, ap: va_list);
}
extern "C" {
    pub fn snprintk(str: *mut cty::c_char, size: usize, fmt: *const cty::c_char, ...)
        -> cty::c_int;
}
extern "C" {
    pub fn vsnprintk(
        str: *mut cty::c_char,
        size: usize,
        fmt: *const cty::c_char,
        ap: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vprintk(
        out: ::core::option::Option<
            unsafe extern "C" fn(arg1: cty::c_int, arg2: *mut cty::c_void) -> cty::c_int,
        >,
        ctx: *mut cty::c_void,
        fmt: *const cty::c_char,
        ap: va_list,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __esf {
    pub __bindgen_anon_1: __esf__bindgen_ty_1,
    pub __bindgen_anon_2: __esf__bindgen_ty_2,
    pub __bindgen_anon_3: __esf__bindgen_ty_3,
    pub __bindgen_anon_4: __esf__bindgen_ty_4,
    pub __bindgen_anon_5: __esf__bindgen_ty_5,
    pub __bindgen_anon_6: __esf__bindgen_ty_6,
    pub __bindgen_anon_7: __esf__bindgen_ty_7,
    pub xpsr: u32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __esf__bindgen_ty_1 {
    pub a1: u32_t,
    pub r0: u32_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___esf__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__esf__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__esf__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__esf__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__esf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_1>())).a1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_1),
            "::",
            stringify!(a1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_1>())).r0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_1),
            "::",
            stringify!(r0)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __esf__bindgen_ty_2 {
    pub a2: u32_t,
    pub r1: u32_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___esf__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<__esf__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(__esf__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<__esf__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(__esf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_2>())).a2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_2),
            "::",
            stringify!(a2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_2>())).r1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_2),
            "::",
            stringify!(r1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __esf__bindgen_ty_3 {
    pub a3: u32_t,
    pub r2: u32_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___esf__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<__esf__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(__esf__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<__esf__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(__esf__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_3>())).a3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_3),
            "::",
            stringify!(a3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_3>())).r2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_3),
            "::",
            stringify!(r2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __esf__bindgen_ty_4 {
    pub a4: u32_t,
    pub r3: u32_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___esf__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<__esf__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(__esf__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<__esf__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(__esf__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_4>())).a4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_4),
            "::",
            stringify!(a4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_4>())).r3 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_4),
            "::",
            stringify!(r3)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __esf__bindgen_ty_5 {
    pub ip: u32_t,
    pub r12: u32_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___esf__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<__esf__bindgen_ty_5>(),
        4usize,
        concat!("Size of: ", stringify!(__esf__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<__esf__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(__esf__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_5>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_5),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_5>())).r12 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_5),
            "::",
            stringify!(r12)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __esf__bindgen_ty_6 {
    pub lr: u32_t,
    pub r14: u32_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___esf__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<__esf__bindgen_ty_6>(),
        4usize,
        concat!("Size of: ", stringify!(__esf__bindgen_ty_6))
    );
    assert_eq!(
        ::core::mem::align_of::<__esf__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(__esf__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_6>())).lr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_6),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_6>())).r14 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_6),
            "::",
            stringify!(r14)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __esf__bindgen_ty_7 {
    pub pc: u32_t,
    pub r15: u32_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___esf__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<__esf__bindgen_ty_7>(),
        4usize,
        concat!("Size of: ", stringify!(__esf__bindgen_ty_7))
    );
    assert_eq!(
        ::core::mem::align_of::<__esf__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(__esf__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_7>())).pc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_7),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf__bindgen_ty_7>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf__bindgen_ty_7),
            "::",
            stringify!(r15)
        )
    );
}
#[test]
fn bindgen_test_layout___esf() {
    assert_eq!(
        ::core::mem::size_of::<__esf>(),
        32usize,
        concat!("Size of: ", stringify!(__esf))
    );
    assert_eq!(
        ::core::mem::align_of::<__esf>(),
        4usize,
        concat!("Alignment of ", stringify!(__esf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__esf>())).xpsr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__esf),
            "::",
            stringify!(xpsr)
        )
    );
}
pub type NANO_ESF = __esf;
extern "C" {
    pub fn _ExcExit();
}
extern "C" {
    #[doc = " @brief display the contents of a exception stack frame"]
    #[doc = ""]
    #[doc = " @return N/A"]
    pub fn sys_exc_esf_dump(esf: *mut NANO_ESF);
}
extern "C" {
    #[doc = " Configure a dynamic interrupt."]
    #[doc = ""]
    #[doc = " Use this instead of IRQ_CONNECT() if arguments cannot be known at build time."]
    #[doc = ""]
    #[doc = " @param irq IRQ line number"]
    #[doc = " @param priority Interrupt priority"]
    #[doc = " @param routine Interrupt service routine"]
    #[doc = " @param parameter ISR parameter"]
    #[doc = " @param flags Arch-specific IRQ configuration flags"]
    #[doc = ""]
    #[doc = " @return The vector assigned to this interrupt"]
    pub fn _arch_irq_connect_dynamic(
        irq: cty::c_uint,
        priority: cty::c_uint,
        routine: ::core::option::Option<unsafe extern "C" fn(parameter: *mut cty::c_void)>,
        parameter: *mut cty::c_void,
        flags: u32_t,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _isr_table_entry {
    pub arg: *mut cty::c_void,
    pub isr: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
}
#[test]
fn bindgen_test_layout__isr_table_entry() {
    assert_eq!(
        ::core::mem::size_of::<_isr_table_entry>(),
        8usize,
        concat!("Size of: ", stringify!(_isr_table_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<_isr_table_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(_isr_table_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_isr_table_entry>())).arg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_table_entry),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_isr_table_entry>())).isr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_table_entry),
            "::",
            stringify!(isr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_sw_isr_table"]
    pub static mut _sw_isr_table: [_isr_table_entry; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _isr_list {
    #[doc = " IRQ line number"]
    pub irq: s32_t,
    #[doc = " Flags for this IRQ, see ISR_FLAG_* definitions"]
    pub flags: s32_t,
    #[doc = " ISR to call"]
    pub func: *mut cty::c_void,
    #[doc = " Parameter for non-direct IRQs"]
    pub param: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout__isr_list() {
    assert_eq!(
        ::core::mem::size_of::<_isr_list>(),
        16usize,
        concat!("Size of: ", stringify!(_isr_list))
    );
    assert_eq!(
        ::core::mem::align_of::<_isr_list>(),
        4usize,
        concat!("Alignment of ", stringify!(_isr_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_isr_list>())).irq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_list),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_isr_list>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_list),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_isr_list>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_list),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_isr_list>())).param as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_isr_list),
            "::",
            stringify!(param)
        )
    );
}
extern "C" {
    pub fn _arch_irq_enable(irq: cty::c_uint);
}
extern "C" {
    pub fn _arch_irq_disable(irq: cty::c_uint);
}
extern "C" {
    pub fn _arch_irq_is_enabled(irq: cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn _IntExit();
}
extern "C" {
    pub fn _irq_priority_set(irq: cty::c_uint, prio: cty::c_uint, flags: u32_t);
}
extern "C" {
    pub fn _arch_isr_direct_header();
}
extern "C" {
    pub fn _irq_spurious(unused: *mut cty::c_void);
}
extern "C" {
    pub fn _isr_wrapper();
}
extern "C" {
    pub fn _NanoFatalErrorHandler(reason: cty::c_uint, esf: *const NANO_ESF);
}
extern "C" {
    pub fn _SysFatalErrorHandler(reason: cty::c_uint, esf: *const NANO_ESF);
}
extern "C" {
    #[doc = " @brief Make the CPU idle."]
    #[doc = ""]
    #[doc = " This function makes the CPU idle until an event wakes it up."]
    #[doc = ""]
    #[doc = " In a regular system, the idle thread should be the only thread responsible"]
    #[doc = " for making the CPU idle and triggering any type of power management."]
    #[doc = " However, in some more constrained systems, such as a single-threaded system,"]
    #[doc = " the only thread would be responsible for this if needed."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-MISC-001"]
    pub fn k_cpu_idle();
}
extern "C" {
    pub fn _timer_cycle_get_32() -> u32_t;
}
pub type paddr_t = cty::c_uint;
pub type vaddr_t = cty::c_uint;
pub type io_port_t = u32_t;
pub type mm_reg_t = u32_t;
pub type mem_addr_t = u32_t;
pub type k_mem_partition_attr_t = u32_t;
extern "C" {
    #[link_name = "\u{1}_sys_clock_always_on"]
    pub static mut _sys_clock_always_on: cty::c_int;
}
extern "C" {
    pub fn _enable_sys_clock();
}
extern "C" {
    #[doc = " @brief Return the lower part of the current system tick count"]
    #[doc = ""]
    #[doc = " @return the current system tick count"]
    #[doc = ""]
    pub fn z_tick_get_32() -> u32_t;
}
extern "C" {
    #[doc = " @brief Return the current system tick count"]
    #[doc = ""]
    #[doc = " @return the current system tick count"]
    #[doc = ""]
    pub fn z_tick_get() -> s64_t;
}
pub type _timeout_func_t = ::core::option::Option<unsafe extern "C" fn(t: *mut _timeout)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _timeout {
    pub node: sys_dnode_t,
    pub dticks: s32_t,
    pub fn_: _timeout_func_t,
}
#[test]
fn bindgen_test_layout__timeout() {
    assert_eq!(
        ::core::mem::size_of::<_timeout>(),
        16usize,
        concat!("Size of: ", stringify!(_timeout))
    );
    assert_eq!(
        ::core::mem::align_of::<_timeout>(),
        4usize,
        concat!("Alignment of ", stringify!(_timeout))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_timeout>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_timeout),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_timeout>())).dticks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_timeout),
            "::",
            stringify!(dticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_timeout>())).fn_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_timeout),
            "::",
            stringify!(fn_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _wait_q_t {
    pub waitq: sys_dlist_t,
}
#[test]
fn bindgen_test_layout__wait_q_t() {
    assert_eq!(
        ::core::mem::size_of::<_wait_q_t>(),
        8usize,
        concat!("Size of: ", stringify!(_wait_q_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_wait_q_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_wait_q_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_wait_q_t>())).waitq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_wait_q_t),
            "::",
            stringify!(waitq)
        )
    );
}
pub const k_objects_K_OBJ_ANY: k_objects = 0;
pub const k_objects_K_OBJ_ALERT: k_objects = 1;
pub const k_objects_K_OBJ_MEM_SLAB: k_objects = 2;
pub const k_objects_K_OBJ_MSGQ: k_objects = 3;
pub const k_objects_K_OBJ_MUTEX: k_objects = 4;
pub const k_objects_K_OBJ_PIPE: k_objects = 5;
pub const k_objects_K_OBJ_QUEUE: k_objects = 6;
pub const k_objects_K_OBJ_POLL_SIGNAL: k_objects = 7;
pub const k_objects_K_OBJ_SEM: k_objects = 8;
pub const k_objects_K_OBJ_STACK: k_objects = 9;
pub const k_objects_K_OBJ_THREAD: k_objects = 10;
pub const k_objects_K_OBJ_TIMER: k_objects = 11;
pub const k_objects_K_OBJ__THREAD_STACK_ELEMENT: k_objects = 12;
pub const k_objects_K_OBJ_DRIVER_ADC: k_objects = 13;
pub const k_objects_K_OBJ_DRIVER_AIO_CMP: k_objects = 14;
pub const k_objects_K_OBJ_DRIVER_COUNTER: k_objects = 15;
pub const k_objects_K_OBJ_DRIVER_CRYPTO: k_objects = 16;
pub const k_objects_K_OBJ_DRIVER_DMA: k_objects = 17;
pub const k_objects_K_OBJ_DRIVER_FLASH: k_objects = 18;
pub const k_objects_K_OBJ_DRIVER_GPIO: k_objects = 19;
pub const k_objects_K_OBJ_DRIVER_I2C: k_objects = 20;
pub const k_objects_K_OBJ_DRIVER_I2S: k_objects = 21;
pub const k_objects_K_OBJ_DRIVER_IPM: k_objects = 22;
pub const k_objects_K_OBJ_DRIVER_LED: k_objects = 23;
pub const k_objects_K_OBJ_DRIVER_PINMUX: k_objects = 24;
pub const k_objects_K_OBJ_DRIVER_PWM: k_objects = 25;
pub const k_objects_K_OBJ_DRIVER_ENTROPY: k_objects = 26;
pub const k_objects_K_OBJ_DRIVER_RTC: k_objects = 27;
pub const k_objects_K_OBJ_DRIVER_SENSOR: k_objects = 28;
pub const k_objects_K_OBJ_DRIVER_SPI: k_objects = 29;
pub const k_objects_K_OBJ_DRIVER_UART: k_objects = 30;
#[doc = " @endcond"]
pub const k_objects_K_OBJ_LAST: k_objects = 31;
pub type k_objects = u32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _k_thread_stack_element {
    pub data: cty::c_char,
}
#[test]
fn bindgen_test_layout__k_thread_stack_element() {
    assert_eq!(
        ::core::mem::size_of::<_k_thread_stack_element>(),
        1usize,
        concat!("Size of: ", stringify!(_k_thread_stack_element))
    );
    assert_eq!(
        ::core::mem::align_of::<_k_thread_stack_element>(),
        1usize,
        concat!("Alignment of ", stringify!(_k_thread_stack_element))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_k_thread_stack_element>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_k_thread_stack_element),
            "::",
            stringify!(data)
        )
    );
}
pub type k_thread_stack_t = _k_thread_stack_element;
#[doc = " @typedef k_thread_entry_t"]
#[doc = " @brief Thread entry point function type."]
#[doc = ""]
#[doc = " A thread\'s entry point function is invoked when the thread starts executing."]
#[doc = " Up to 3 argument values can be passed to the function."]
#[doc = ""]
#[doc = " The thread terminates execution permanently if the entry point function"]
#[doc = " returns. The thread is responsible for releasing any shared resources"]
#[doc = " it may own (such as mutexes and dynamically allocated memory), prior to"]
#[doc = " returning."]
#[doc = ""]
#[doc = " @param p1 First argument."]
#[doc = " @param p2 Second argument."]
#[doc = " @param p3 Third argument."]
#[doc = ""]
#[doc = " @return N/A"]
pub type k_thread_entry_t = ::core::option::Option<
    unsafe extern "C" fn(p1: *mut cty::c_void, p2: *mut cty::c_void, p3: *mut cty::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _thread_base {
    pub __bindgen_anon_1: _thread_base__bindgen_ty_1,
    pub pended_on: *mut _wait_q_t,
    pub user_options: u8_t,
    pub thread_state: u8_t,
    pub __bindgen_anon_2: _thread_base__bindgen_ty_2,
    pub order_key: u32_t,
    pub swap_data: *mut cty::c_void,
    pub timeout: _timeout,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _thread_base__bindgen_ty_1 {
    pub qnode_dlist: sys_dlist_t,
    pub qnode_rb: rbnode,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout__thread_base__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_thread_base__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_thread_base__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_thread_base__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_thread_base__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_thread_base__bindgen_ty_1>())).qnode_dlist as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base__bindgen_ty_1),
            "::",
            stringify!(qnode_dlist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_thread_base__bindgen_ty_1>())).qnode_rb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base__bindgen_ty_1),
            "::",
            stringify!(qnode_rb)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _thread_base__bindgen_ty_2 {
    pub __bindgen_anon_1: _thread_base__bindgen_ty_2__bindgen_ty_1,
    pub preempt: u16_t,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _thread_base__bindgen_ty_2__bindgen_ty_1 {
    pub prio: s8_t,
    pub sched_locked: u8_t,
}
#[test]
fn bindgen_test_layout__thread_base__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_thread_base__bindgen_ty_2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(_thread_base__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_thread_base__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_thread_base__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_thread_base__bindgen_ty_2__bindgen_ty_1>())).prio as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_thread_base__bindgen_ty_2__bindgen_ty_1>())).sched_locked
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(sched_locked)
        )
    );
}
#[test]
fn bindgen_test_layout__thread_base__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_thread_base__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(_thread_base__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_thread_base__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(_thread_base__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_thread_base__bindgen_ty_2>())).preempt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base__bindgen_ty_2),
            "::",
            stringify!(preempt)
        )
    );
}
#[test]
fn bindgen_test_layout__thread_base() {
    assert_eq!(
        ::core::mem::size_of::<_thread_base>(),
        40usize,
        concat!("Size of: ", stringify!(_thread_base))
    );
    assert_eq!(
        ::core::mem::align_of::<_thread_base>(),
        4usize,
        concat!("Alignment of ", stringify!(_thread_base))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_thread_base>())).pended_on as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base),
            "::",
            stringify!(pended_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_thread_base>())).user_options as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base),
            "::",
            stringify!(user_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_thread_base>())).thread_state as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base),
            "::",
            stringify!(thread_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_thread_base>())).order_key as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base),
            "::",
            stringify!(order_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_thread_base>())).swap_data as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base),
            "::",
            stringify!(swap_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_thread_base>())).timeout as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_base),
            "::",
            stringify!(timeout)
        )
    );
}
pub type _thread_base_t = _thread_base;
#[doc = " @ingroup thread_apis"]
#[doc = " Thread Structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_thread {
    pub base: _thread_base,
    #[doc = " defined by the architecture, but all archs need these"]
    pub caller_saved: _caller_saved,
    #[doc = " defined by the architecture, but all archs need these"]
    pub callee_saved: _callee_saved,
    #[doc = " static thread init data"]
    pub init_data: *mut cty::c_void,
    #[doc = " abort function"]
    #[doc = " @req K-THREAD-002"]
    pub fn_abort: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = " per-thread errno variable"]
    pub errno_var: cty::c_int,
    #[doc = " resource pool"]
    pub resource_pool: *mut k_mem_pool,
    #[doc = " arch-specifics: must always be at the end"]
    pub arch: _thread_arch,
}
#[test]
fn bindgen_test_layout_k_thread() {
    assert_eq!(
        ::core::mem::size_of::<k_thread>(),
        100usize,
        concat!("Size of: ", stringify!(k_thread))
    );
    assert_eq!(
        ::core::mem::align_of::<k_thread>(),
        4usize,
        concat!("Alignment of ", stringify!(k_thread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_thread>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_thread>())).caller_saved as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(caller_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_thread>())).callee_saved as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(callee_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_thread>())).init_data as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(init_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_thread>())).fn_abort as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(fn_abort)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_thread>())).errno_var as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(errno_var)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_thread>())).resource_pool as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(resource_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_thread>())).arch as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(k_thread),
            "::",
            stringify!(arch)
        )
    );
}
pub type _thread_t = k_thread;
pub type k_tid_t = *mut k_thread;
pub const execution_context_types_K_ISR: execution_context_types = 0;
pub const execution_context_types_K_COOP_THREAD: execution_context_types = 1;
pub const execution_context_types_K_PREEMPT_THREAD: execution_context_types = 2;
pub type execution_context_types = u32;
#[doc = " @defgroup profiling_apis Profiling APIs"]
#[doc = " @ingroup kernel_apis"]
#[doc = " @{"]
pub type k_thread_user_cb_t = ::core::option::Option<
    unsafe extern "C" fn(thread: *const k_thread, user_data: *mut cty::c_void),
>;
extern "C" {
    #[doc = " @brief Iterate over all the threads in the system."]
    #[doc = ""]
    #[doc = " This routine iterates over all the threads in the system and"]
    #[doc = " calls the user_cb function for each thread."]
    #[doc = ""]
    #[doc = " @param user_cb Pointer to the user callback function."]
    #[doc = " @param user_data Pointer to user data."]
    #[doc = ""]
    #[doc = " @note CONFIG_THREAD_MONITOR must be set for this function"]
    #[doc = " to be effective. Also this API uses irq_lock to protect the"]
    #[doc = " _kernel.threads list which means creation of new threads and"]
    #[doc = " terminations of existing threads are blocked until this"]
    #[doc = " API returns."]
    #[doc = ""]
    #[doc = " @return N/A"]
    pub fn k_thread_foreach(user_cb: k_thread_user_cb_t, user_data: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Drop a thread\'s privileges permanently to user mode"]
    #[doc = ""]
    #[doc = " @param entry Function to start executing from"]
    #[doc = " @param p1 1st entry point parameter"]
    #[doc = " @param p2 2nd entry point parameter"]
    #[doc = " @param p3 3rd entry point parameter"]
    #[doc = " @req K-THREAD-003"]
    pub fn k_thread_user_mode_enter(
        entry: k_thread_entry_t,
        p1: *mut cty::c_void,
        p2: *mut cty::c_void,
        p3: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @brief Grant a thread access to a NULL-terminated  set of kernel objects"]
    #[doc = ""]
    #[doc = " This is a convenience function. For the provided thread, grant access to"]
    #[doc = " the remaining arguments, which must be pointers to kernel objects."]
    #[doc = " The final argument must be a NULL."]
    #[doc = ""]
    #[doc = " The thread object must be initialized (i.e. running). The objects don\'t"]
    #[doc = " need to be."]
    #[doc = ""]
    #[doc = " @param thread Thread to grant access to objects"]
    #[doc = " @param ... NULL-terminated list of kernel object pointers"]
    #[doc = " @req K-THREAD-004"]
    pub fn k_thread_access_grant(thread: *mut k_thread, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _static_thread_data {
    pub init_thread: *mut k_thread,
    pub init_stack: *mut k_thread_stack_t,
    pub init_stack_size: cty::c_uint,
    pub init_entry: k_thread_entry_t,
    pub init_p1: *mut cty::c_void,
    pub init_p2: *mut cty::c_void,
    pub init_p3: *mut cty::c_void,
    pub init_prio: cty::c_int,
    pub init_options: u32_t,
    pub init_delay: s32_t,
    pub init_abort: ::core::option::Option<unsafe extern "C" fn()>,
    pub init_name: *const cty::c_char,
}
#[test]
fn bindgen_test_layout__static_thread_data() {
    assert_eq!(
        ::core::mem::size_of::<_static_thread_data>(),
        48usize,
        concat!("Size of: ", stringify!(_static_thread_data))
    );
    assert_eq!(
        ::core::mem::align_of::<_static_thread_data>(),
        4usize,
        concat!("Alignment of ", stringify!(_static_thread_data))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_static_thread_data>())).init_thread as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_static_thread_data>())).init_stack as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_stack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_static_thread_data>())).init_stack_size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_stack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_static_thread_data>())).init_entry as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_static_thread_data>())).init_p1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_p1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_static_thread_data>())).init_p2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_p2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_static_thread_data>())).init_p3 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_p3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_static_thread_data>())).init_prio as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_prio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_static_thread_data>())).init_options as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_static_thread_data>())).init_delay as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_static_thread_data>())).init_abort as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_abort)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_static_thread_data>())).init_name as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_static_thread_data),
            "::",
            stringify!(init_name)
        )
    );
}
extern "C" {
    #[doc = " @brief Set time-slicing period and scope."]
    #[doc = ""]
    #[doc = " This routine specifies how the scheduler will perform time slicing of"]
    #[doc = " preemptible threads."]
    #[doc = ""]
    #[doc = " To enable time slicing, @a slice must be non-zero. The scheduler"]
    #[doc = " ensures that no thread runs for more than the specified time limit"]
    #[doc = " before other threads of that priority are given a chance to execute."]
    #[doc = " Any thread whose priority is higher than @a prio is exempted, and may"]
    #[doc = " execute as long as desired without being preempted due to time slicing."]
    #[doc = ""]
    #[doc = " Time slicing only limits the maximum amount of time a thread may continuously"]
    #[doc = " execute. Once the scheduler selects a thread for execution, there is no"]
    #[doc = " minimum guaranteed time the thread will execute before threads of greater or"]
    #[doc = " equal priority are scheduled."]
    #[doc = ""]
    #[doc = " When the current thread is the only one of that priority eligible"]
    #[doc = " for execution, this routine has no effect; the thread is immediately"]
    #[doc = " rescheduled after the slice period expires."]
    #[doc = ""]
    #[doc = " To disable timeslicing, set both @a slice and @a prio to zero."]
    #[doc = ""]
    #[doc = " @param slice Maximum time slice length (in milliseconds)."]
    #[doc = " @param prio Highest thread priority level eligible for time slicing."]
    #[doc = ""]
    #[doc = " @return N/A"]
    pub fn k_sched_time_slice_set(slice: s32_t, prio: cty::c_int);
}
extern "C" {
    #[doc = " @brief Determine if code is running at interrupt level."]
    #[doc = ""]
    #[doc = " This routine allows the caller to customize its actions, depending on"]
    #[doc = " whether it is a thread or an ISR."]
    #[doc = ""]
    #[doc = " @note Can be called by ISRs."]
    #[doc = ""]
    #[doc = " @return 0 if invoked by a thread."]
    #[doc = " @return Non-zero if invoked by an ISR."]
    pub fn k_is_in_isr() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Lock the scheduler."]
    #[doc = ""]
    #[doc = " This routine prevents the current thread from being preempted by another"]
    #[doc = " thread by instructing the scheduler to treat it as a cooperative thread."]
    #[doc = " If the thread subsequently performs an operation that makes it unready,"]
    #[doc = " it will be context switched out in the normal manner. When the thread"]
    #[doc = " again becomes the current thread, its non-preemptible status is maintained."]
    #[doc = ""]
    #[doc = " This routine can be called recursively."]
    #[doc = ""]
    #[doc = " @note k_sched_lock() and k_sched_unlock() should normally be used"]
    #[doc = " when the operation being performed can be safely interrupted by ISRs."]
    #[doc = " However, if the amount of processing involved is very small, better"]
    #[doc = " performance may be obtained by using irq_lock() and irq_unlock()."]
    #[doc = ""]
    #[doc = " @return N/A"]
    pub fn k_sched_lock();
}
extern "C" {
    #[doc = " @brief Unlock the scheduler."]
    #[doc = ""]
    #[doc = " This routine reverses the effect of a previous call to k_sched_lock()."]
    #[doc = " A thread must call the routine once for each time it called k_sched_lock()"]
    #[doc = " before the thread becomes preemptible."]
    #[doc = ""]
    #[doc = " @return N/A"]
    pub fn k_sched_unlock();
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
pub struct k_timer {
    pub timeout: _timeout,
    pub wait_q: _wait_q_t,
    pub expiry_fn: ::core::option::Option<unsafe extern "C" fn(arg1: *mut k_timer)>,
    pub stop_fn: ::core::option::Option<unsafe extern "C" fn(arg1: *mut k_timer)>,
    pub period: s32_t,
    pub status: u32_t,
    pub user_data: *mut cty::c_void,
    pub __dummy_next: __IncompleteArrayField<u8_t>,
}
#[test]
fn bindgen_test_layout_k_timer() {
    assert_eq!(
        ::core::mem::size_of::<k_timer>(),
        44usize,
        concat!("Size of: ", stringify!(k_timer))
    );
    assert_eq!(
        ::core::mem::align_of::<k_timer>(),
        4usize,
        concat!("Alignment of ", stringify!(k_timer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_timer>())).timeout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_timer>())).wait_q as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_timer>())).expiry_fn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(expiry_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_timer>())).stop_fn as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(stop_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_timer>())).period as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_timer>())).status as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_timer>())).user_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_timer>())).__dummy_next as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(k_timer),
            "::",
            stringify!(__dummy_next)
        )
    );
}
#[doc = " @typedef k_timer_expiry_t"]
#[doc = " @brief Timer expiry function type."]
#[doc = ""]
#[doc = " A timer\'s expiry function is executed by the system clock interrupt handler"]
#[doc = " each time the timer expires. The expiry function is optional, and is only"]
#[doc = " invoked if the timer has been initialized with one."]
#[doc = ""]
#[doc = " @param timer     Address of timer."]
#[doc = ""]
#[doc = " @return N/A"]
pub type k_timer_expiry_t = ::core::option::Option<unsafe extern "C" fn(timer: *mut k_timer)>;
#[doc = " @typedef k_timer_stop_t"]
#[doc = " @brief Timer stop function type."]
#[doc = ""]
#[doc = " A timer\'s stop function is executed if the timer is stopped prematurely."]
#[doc = " The function runs in the context of the thread that stops the timer."]
#[doc = " The stop function is optional, and is only invoked if the timer has been"]
#[doc = " initialized with one."]
#[doc = ""]
#[doc = " @param timer     Address of timer."]
#[doc = ""]
#[doc = " @return N/A"]
pub type k_timer_stop_t = ::core::option::Option<unsafe extern "C" fn(timer: *mut k_timer)>;
extern "C" {
    #[doc = " @brief Initialize a timer."]
    #[doc = ""]
    #[doc = " This routine initializes a timer, prior to its first use."]
    #[doc = ""]
    #[doc = " @param timer     Address of timer."]
    #[doc = " @param expiry_fn Function to invoke each time the timer expires."]
    #[doc = " @param stop_fn   Function to invoke if the timer is stopped while running."]
    #[doc = ""]
    #[doc = " @return N/A"]
    pub fn k_timer_init(timer: *mut k_timer, expiry_fn: k_timer_expiry_t, stop_fn: k_timer_stop_t);
}
extern "C" {
    pub fn z_timeout_remaining(timeout: *mut _timeout) -> s32_t;
}
extern "C" {
    #[doc = " @brief Enable clock always on in tickless kernel"]
    #[doc = ""]
    #[doc = " This routine enables keeping the clock running (that is, it always"]
    #[doc = " keeps an active timer interrupt scheduled) when there are no timer"]
    #[doc = " events programmed in tickless kernel scheduling. This is necessary"]
    #[doc = " if the clock is used to track passage of time (e.g. via"]
    #[doc = " k_uptime_get_32()), otherwise the internal hardware counter may"]
    #[doc = " roll over between interrupts."]
    #[doc = ""]
    #[doc = " @retval prev_status Previous status of always on flag"]
    pub fn k_enable_sys_clock_always_on() -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Disable clock always on in tickless kernel"]
    #[doc = ""]
    #[doc = " This routine disables keeping the clock running when"]
    #[doc = " there are no timer events programmed in tickless kernel"]
    #[doc = " scheduling. To save power, this routine should be called"]
    #[doc = " immediately when clock is not used to track time."]
    pub fn k_disable_sys_clock_always_on();
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
pub struct k_queue {
    pub data_q: sys_sflist_t,
    pub __bindgen_anon_1: k_queue__bindgen_ty_1,
    pub __dummy_next: __IncompleteArrayField<u8_t>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_queue__bindgen_ty_1 {
    pub wait_q: _wait_q_t,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_k_queue__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<k_queue__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(k_queue__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<k_queue__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(k_queue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_queue__bindgen_ty_1>())).wait_q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_queue__bindgen_ty_1),
            "::",
            stringify!(wait_q)
        )
    );
}
#[test]
fn bindgen_test_layout_k_queue() {
    assert_eq!(
        ::core::mem::size_of::<k_queue>(),
        16usize,
        concat!("Size of: ", stringify!(k_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<k_queue>(),
        4usize,
        concat!("Alignment of ", stringify!(k_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_queue>())).data_q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_queue),
            "::",
            stringify!(data_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_queue>())).__dummy_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_queue),
            "::",
            stringify!(__dummy_next)
        )
    );
}
extern "C" {
    pub fn z_queue_node_peek(node: *mut sys_sfnode_t, needs_free: bool) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Append an element to the end of a queue."]
    #[doc = ""]
    #[doc = " This routine appends a data item to @a queue. A queue data item must be"]
    #[doc = " aligned on a 4-byte boundary, and the first 32 bits of the item are"]
    #[doc = " reserved for the kernel\'s use."]
    #[doc = ""]
    #[doc = " @note Can be called by ISRs."]
    #[doc = ""]
    #[doc = " @param queue Address of the queue."]
    #[doc = " @param data Address of the data item."]
    #[doc = ""]
    #[doc = " @return N/A"]
    pub fn k_queue_append(queue: *mut k_queue, data: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Prepend an element to a queue."]
    #[doc = ""]
    #[doc = " This routine prepends a data item to @a queue. A queue data item must be"]
    #[doc = " aligned on a 4-byte boundary, and the first 32 bits of the item are"]
    #[doc = " reserved for the kernel\'s use."]
    #[doc = ""]
    #[doc = " @note Can be called by ISRs."]
    #[doc = ""]
    #[doc = " @param queue Address of the queue."]
    #[doc = " @param data Address of the data item."]
    #[doc = ""]
    #[doc = " @return N/A"]
    pub fn k_queue_prepend(queue: *mut k_queue, data: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Inserts an element to a queue."]
    #[doc = ""]
    #[doc = " This routine inserts a data item to @a queue after previous item. A queue"]
    #[doc = " data item must be aligned on a 4-byte boundary, and the first 32 bits of the"]
    #[doc = " item are reserved for the kernel\'s use."]
    #[doc = ""]
    #[doc = " @note Can be called by ISRs."]
    #[doc = ""]
    #[doc = " @param queue Address of the queue."]
    #[doc = " @param prev Address of the previous data item."]
    #[doc = " @param data Address of the data item."]
    #[doc = ""]
    #[doc = " @return N/A"]
    pub fn k_queue_insert(queue: *mut k_queue, prev: *mut cty::c_void, data: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Atomically append a list of elements to a queue."]
    #[doc = ""]
    #[doc = " This routine adds a list of data items to @a queue in one operation."]
    #[doc = " The data items must be in a singly-linked list, with the first 32 bits"]
    #[doc = " in each data item pointing to the next data item; the list must be"]
    #[doc = " NULL-terminated."]
    #[doc = ""]
    #[doc = " @note Can be called by ISRs."]
    #[doc = ""]
    #[doc = " @param queue Address of the queue."]
    #[doc = " @param head Pointer to first node in singly-linked list."]
    #[doc = " @param tail Pointer to last node in singly-linked list."]
    #[doc = ""]
    #[doc = " @return N/A"]
    pub fn k_queue_append_list(queue: *mut k_queue, head: *mut cty::c_void, tail: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Atomically add a list of elements to a queue."]
    #[doc = ""]
    #[doc = " This routine adds a list of data items to @a queue in one operation."]
    #[doc = " The data items must be in a singly-linked list implemented using a"]
    #[doc = " sys_slist_t object. Upon completion, the original list is empty."]
    #[doc = ""]
    #[doc = " @note Can be called by ISRs."]
    #[doc = ""]
    #[doc = " @param queue Address of the queue."]
    #[doc = " @param list Pointer to sys_slist_t object."]
    #[doc = ""]
    #[doc = " @return N/A"]
    pub fn k_queue_merge_slist(queue: *mut k_queue, list: *mut sys_slist_t);
}
#[doc = " @}"]
#[repr(C)]
pub struct k_fifo {
    pub _queue: k_queue,
}
#[test]
fn bindgen_test_layout_k_fifo() {
    assert_eq!(
        ::core::mem::size_of::<k_fifo>(),
        16usize,
        concat!("Size of: ", stringify!(k_fifo))
    );
    assert_eq!(
        ::core::mem::align_of::<k_fifo>(),
        4usize,
        concat!("Alignment of ", stringify!(k_fifo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_fifo>()))._queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_fifo),
            "::",
            stringify!(_queue)
        )
    );
}
#[doc = " @}"]
#[repr(C)]
pub struct k_lifo {
    pub _queue: k_queue,
}
#[test]
fn bindgen_test_layout_k_lifo() {
    assert_eq!(
        ::core::mem::size_of::<k_lifo>(),
        16usize,
        concat!("Size of: ", stringify!(k_lifo))
    );
    assert_eq!(
        ::core::mem::align_of::<k_lifo>(),
        4usize,
        concat!("Alignment of ", stringify!(k_lifo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_lifo>()))._queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_lifo),
            "::",
            stringify!(_queue)
        )
    );
}
#[repr(C)]
pub struct k_stack {
    pub wait_q: _wait_q_t,
    pub base: *mut u32_t,
    pub next: *mut u32_t,
    pub top: *mut u32_t,
    pub __dummy_next: __IncompleteArrayField<u8_t>,
    pub flags: u8_t,
}
#[test]
fn bindgen_test_layout_k_stack() {
    assert_eq!(
        ::core::mem::size_of::<k_stack>(),
        24usize,
        concat!("Size of: ", stringify!(k_stack))
    );
    assert_eq!(
        ::core::mem::align_of::<k_stack>(),
        4usize,
        concat!("Alignment of ", stringify!(k_stack))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_stack>())).wait_q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_stack>())).base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_stack>())).next as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_stack>())).top as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_stack>())).__dummy_next as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(__dummy_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_stack>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_stack),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a stack."]
    #[doc = ""]
    #[doc = " This routine initializes a stack object, prior to its first use."]
    #[doc = ""]
    #[doc = " @param stack Address of the stack."]
    #[doc = " @param buffer Address of array used to hold stacked values."]
    #[doc = " @param num_entries Maximum number of values that can be stacked."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-STACK-001"]
    pub fn k_stack_init(stack: *mut k_stack, buffer: *mut u32_t, num_entries: u32_t);
}
extern "C" {
    #[doc = " @brief Release a stack\'s allocated buffer"]
    #[doc = ""]
    #[doc = " If a stack object was given a dynamically allocated buffer via"]
    #[doc = " k_stack_alloc_init(), this will free it. This function does nothing"]
    #[doc = " if the buffer wasn\'t dynamically allocated."]
    #[doc = ""]
    #[doc = " @param stack Address of the stack."]
    #[doc = " @req K-STACK-001"]
    pub fn k_stack_cleanup(stack: *mut k_stack);
}
#[doc = " @typedef k_work_handler_t"]
#[doc = " @brief Work item handler function type."]
#[doc = ""]
#[doc = " A work item\'s handler function is executed by a workqueue\'s thread"]
#[doc = " when the work item is processed by the workqueue."]
#[doc = ""]
#[doc = " @param work Address of the work item."]
#[doc = ""]
#[doc = " @return N/A"]
#[doc = " @req K-WORK-001"]
pub type k_work_handler_t = ::core::option::Option<unsafe extern "C" fn(work: *mut k_work)>;
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
pub struct k_work_q {
    pub queue: k_queue,
    pub thread: k_thread,
}
#[test]
fn bindgen_test_layout_k_work_q() {
    assert_eq!(
        ::core::mem::size_of::<k_work_q>(),
        116usize,
        concat!("Size of: ", stringify!(k_work_q))
    );
    assert_eq!(
        ::core::mem::align_of::<k_work_q>(),
        4usize,
        concat!("Alignment of ", stringify!(k_work_q))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_work_q>())).queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_q),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_work_q>())).thread as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work_q),
            "::",
            stringify!(thread)
        )
    );
}
pub const K_WORK_STATE_PENDING: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = u32;
#[doc = " @}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_work {
    pub _reserved: *mut cty::c_void,
    pub handler: k_work_handler_t,
    pub flags: [atomic_t; 1usize],
}
#[test]
fn bindgen_test_layout_k_work() {
    assert_eq!(
        ::core::mem::size_of::<k_work>(),
        12usize,
        concat!("Size of: ", stringify!(k_work))
    );
    assert_eq!(
        ::core::mem::align_of::<k_work>(),
        4usize,
        concat!("Alignment of ", stringify!(k_work))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_work>()))._reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work),
            "::",
            stringify!(_reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_work>())).handler as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_work>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_work),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_delayed_work {
    pub work: k_work,
    pub timeout: _timeout,
    pub work_q: *mut k_work_q,
}
#[test]
fn bindgen_test_layout_k_delayed_work() {
    assert_eq!(
        ::core::mem::size_of::<k_delayed_work>(),
        32usize,
        concat!("Size of: ", stringify!(k_delayed_work))
    );
    assert_eq!(
        ::core::mem::align_of::<k_delayed_work>(),
        4usize,
        concat!("Alignment of ", stringify!(k_delayed_work))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_delayed_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_delayed_work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_delayed_work>())).timeout as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k_delayed_work),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_delayed_work>())).work_q as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(k_delayed_work),
            "::",
            stringify!(work_q)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}k_sys_work_q"]
    pub static mut k_sys_work_q: k_work_q;
}
extern "C" {
    #[doc = " @brief Start a workqueue."]
    #[doc = ""]
    #[doc = " This routine starts workqueue @a work_q. The workqueue spawns its work"]
    #[doc = " processing thread, which runs forever."]
    #[doc = ""]
    #[doc = " @param work_q Address of workqueue."]
    #[doc = " @param stack Pointer to work queue thread\'s stack space, as defined by"]
    #[doc = "\t\tK_THREAD_STACK_DEFINE()"]
    #[doc = " @param stack_size Size of the work queue thread\'s stack (in bytes), which"]
    #[doc = "\t\tshould either be the same constant passed to"]
    #[doc = "\t\tK_THREAD_STACK_DEFINE() or the value of K_THREAD_STACK_SIZEOF()."]
    #[doc = " @param prio Priority of the work queue\'s thread."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-WORK-001"]
    pub fn k_work_q_start(
        work_q: *mut k_work_q,
        stack: *mut k_thread_stack_t,
        stack_size: usize,
        prio: cty::c_int,
    );
}
extern "C" {
    #[doc = " @brief Start a workqueue in user mode"]
    #[doc = ""]
    #[doc = " This works identically to k_work_q_start() except it is callable from user"]
    #[doc = " mode, and the worker thread created will run in user mode."]
    #[doc = " The caller must have permissions granted on both the work_q parameter\'s"]
    #[doc = " thread and queue objects, and the same restrictions on priority apply as"]
    #[doc = " k_thread_create()."]
    #[doc = ""]
    #[doc = " @param work_q Address of workqueue."]
    #[doc = " @param stack Pointer to work queue thread\'s stack space, as defined by"]
    #[doc = "\t\tK_THREAD_STACK_DEFINE()"]
    #[doc = " @param stack_size Size of the work queue thread\'s stack (in bytes), which"]
    #[doc = "\t\tshould either be the same constant passed to"]
    #[doc = "\t\tK_THREAD_STACK_DEFINE() or the value of K_THREAD_STACK_SIZEOF()."]
    #[doc = " @param prio Priority of the work queue\'s thread."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-WORK-001"]
    pub fn k_work_q_user_start(
        work_q: *mut k_work_q,
        stack: *mut k_thread_stack_t,
        stack_size: usize,
        prio: cty::c_int,
    );
}
extern "C" {
    #[doc = " @brief Initialize a delayed work item."]
    #[doc = ""]
    #[doc = " This routine initializes a workqueue delayed work item, prior to"]
    #[doc = " its first use."]
    #[doc = ""]
    #[doc = " @param work Address of delayed work item."]
    #[doc = " @param handler Function to invoke each time work item is processed."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-DWORK-001"]
    pub fn k_delayed_work_init(work: *mut k_delayed_work, handler: k_work_handler_t);
}
extern "C" {
    #[doc = " @brief Submit a delayed work item."]
    #[doc = ""]
    #[doc = " This routine schedules work item @a work to be processed by workqueue"]
    #[doc = " @a work_q after a delay of @a delay milliseconds. The routine initiates"]
    #[doc = " an asynchronous countdown for the work item and then returns to the caller."]
    #[doc = " Only when the countdown completes is the work item actually submitted to"]
    #[doc = " the workqueue and becomes pending."]
    #[doc = ""]
    #[doc = " Submitting a previously submitted delayed work item that is still"]
    #[doc = " counting down cancels the existing submission and restarts the"]
    #[doc = " countdown using the new delay.  Note that this behavior is"]
    #[doc = " inherently subject to race conditions with the pre-existing"]
    #[doc = " timeouts and work queue, so care must be taken to synchronize such"]
    #[doc = " resubmissions externally."]
    #[doc = ""]
    #[doc = " @warning"]
    #[doc = " A delayed work item must not be modified until it has been processed"]
    #[doc = " by the workqueue."]
    #[doc = ""]
    #[doc = " @note Can be called by ISRs."]
    #[doc = ""]
    #[doc = " @param work_q Address of workqueue."]
    #[doc = " @param work Address of delayed work item."]
    #[doc = " @param delay Delay before submitting the work item (in milliseconds)."]
    #[doc = ""]
    #[doc = " @retval 0 Work item countdown started."]
    #[doc = " @retval -EINPROGRESS Work item is already pending."]
    #[doc = " @retval -EINVAL Work item is being processed or has completed its work."]
    #[doc = " @retval -EADDRINUSE Work item is pending on a different workqueue."]
    #[doc = " @req K-DWORK-001"]
    pub fn k_delayed_work_submit_to_queue(
        work_q: *mut k_work_q,
        work: *mut k_delayed_work,
        delay: s32_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Cancel a delayed work item."]
    #[doc = ""]
    #[doc = " This routine cancels the submission of delayed work item @a work."]
    #[doc = " A delayed work item can only be canceled while its countdown is still"]
    #[doc = " underway."]
    #[doc = ""]
    #[doc = " @note Can be called by ISRs."]
    #[doc = ""]
    #[doc = " @param work Address of delayed work item."]
    #[doc = ""]
    #[doc = " @retval 0 Work item countdown canceled."]
    #[doc = " @retval -EINPROGRESS Work item is already pending."]
    #[doc = " @retval -EINVAL Work item is being processed or has completed its work."]
    #[doc = " @req K-DWORK-001"]
    pub fn k_delayed_work_cancel(work: *mut k_delayed_work) -> cty::c_int;
}
#[doc = " Mutex Structure"]
#[doc = " @ingroup mutex_apis"]
#[repr(C)]
pub struct k_mutex {
    pub wait_q: _wait_q_t,
    #[doc = " Mutex owner"]
    pub owner: *mut k_thread,
    pub lock_count: u32_t,
    pub owner_orig_prio: cty::c_int,
    pub __dummy_next: __IncompleteArrayField<u8_t>,
}
#[test]
fn bindgen_test_layout_k_mutex() {
    assert_eq!(
        ::core::mem::size_of::<k_mutex>(),
        20usize,
        concat!("Size of: ", stringify!(k_mutex))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mutex>(),
        4usize,
        concat!("Alignment of ", stringify!(k_mutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mutex>())).wait_q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mutex),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mutex>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mutex>())).lock_count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mutex),
            "::",
            stringify!(lock_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mutex>())).owner_orig_prio as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mutex),
            "::",
            stringify!(owner_orig_prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mutex>())).__dummy_next as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mutex),
            "::",
            stringify!(__dummy_next)
        )
    );
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
pub struct k_sem {
    pub wait_q: _wait_q_t,
    pub count: u32_t,
    pub limit: u32_t,
    pub __dummy_next: __IncompleteArrayField<u8_t>,
}
#[test]
fn bindgen_test_layout_k_sem() {
    assert_eq!(
        ::core::mem::size_of::<k_sem>(),
        16usize,
        concat!("Size of: ", stringify!(k_sem))
    );
    assert_eq!(
        ::core::mem::align_of::<k_sem>(),
        4usize,
        concat!("Alignment of ", stringify!(k_sem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_sem>())).wait_q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_sem),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_sem>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_sem),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_sem>())).limit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k_sem),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_sem>())).__dummy_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_sem),
            "::",
            stringify!(__dummy_next)
        )
    );
}
#[doc = " @typedef k_alert_handler_t"]
#[doc = " @brief Alert handler function type."]
#[doc = ""]
#[doc = " An alert\'s alert handler function is invoked by the system workqueue"]
#[doc = " when the alert is signaled. The alert handler function is optional,"]
#[doc = " and is only invoked if the alert has been initialized with one."]
#[doc = ""]
#[doc = " @param alert Address of the alert."]
#[doc = ""]
#[doc = " @return 0 if alert has been consumed; non-zero if alert should pend."]
pub type k_alert_handler_t =
    ::core::option::Option<unsafe extern "C" fn(alert: *mut k_alert) -> cty::c_int>;
#[repr(C)]
pub struct k_alert {
    pub handler: k_alert_handler_t,
    pub send_count: atomic_t,
    pub work_item: k_work,
    pub sem: k_sem,
    pub __dummy_next: __IncompleteArrayField<u8_t>,
}
#[test]
fn bindgen_test_layout_k_alert() {
    assert_eq!(
        ::core::mem::size_of::<k_alert>(),
        36usize,
        concat!("Size of: ", stringify!(k_alert))
    );
    assert_eq!(
        ::core::mem::align_of::<k_alert>(),
        4usize,
        concat!("Alignment of ", stringify!(k_alert))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_alert>())).handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_alert),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_alert>())).send_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k_alert),
            "::",
            stringify!(send_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_alert>())).work_item as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_alert),
            "::",
            stringify!(work_item)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_alert>())).sem as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_alert),
            "::",
            stringify!(sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_alert>())).__dummy_next as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(k_alert),
            "::",
            stringify!(__dummy_next)
        )
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn _alert_deliver(work: *mut k_work);
}
extern "C" {
    #[doc = " @brief Initialize an alert."]
    #[doc = ""]
    #[doc = " This routine initializes an alert object, prior to its first use."]
    #[doc = ""]
    #[doc = " @param alert Address of the alert."]
    #[doc = " @param handler Action to take when alert is sent. Specify either the address"]
    #[doc = "                of a function to be invoked by the system workqueue thread,"]
    #[doc = "                K_ALERT_IGNORE (which causes the alert to be ignored), or"]
    #[doc = "                K_ALERT_DEFAULT (which causes the alert to pend)."]
    #[doc = " @param max_num_pending_alerts Maximum number of pending alerts."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-ALERT-002"]
    pub fn k_alert_init(
        alert: *mut k_alert,
        handler: k_alert_handler_t,
        max_num_pending_alerts: cty::c_uint,
    );
}
#[doc = " @brief Message Queue Structure"]
#[repr(C)]
pub struct k_msgq {
    pub wait_q: _wait_q_t,
    pub msg_size: usize,
    pub max_msgs: u32_t,
    pub buffer_start: *mut cty::c_char,
    pub buffer_end: *mut cty::c_char,
    pub read_ptr: *mut cty::c_char,
    pub write_ptr: *mut cty::c_char,
    pub used_msgs: u32_t,
    pub __dummy_next: __IncompleteArrayField<u8_t>,
    pub flags: u8_t,
}
#[test]
fn bindgen_test_layout_k_msgq() {
    assert_eq!(
        ::core::mem::size_of::<k_msgq>(),
        40usize,
        concat!("Size of: ", stringify!(k_msgq))
    );
    assert_eq!(
        ::core::mem::align_of::<k_msgq>(),
        4usize,
        concat!("Alignment of ", stringify!(k_msgq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq>())).wait_q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq>())).msg_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(msg_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq>())).max_msgs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(max_msgs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq>())).buffer_start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(buffer_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq>())).buffer_end as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(buffer_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq>())).read_ptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq>())).write_ptr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq>())).used_msgs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(used_msgs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq>())).__dummy_next as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(__dummy_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq>())).flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " @brief Message Queue Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_msgq_attrs {
    pub msg_size: usize,
    pub max_msgs: u32_t,
    pub used_msgs: u32_t,
}
#[test]
fn bindgen_test_layout_k_msgq_attrs() {
    assert_eq!(
        ::core::mem::size_of::<k_msgq_attrs>(),
        12usize,
        concat!("Size of: ", stringify!(k_msgq_attrs))
    );
    assert_eq!(
        ::core::mem::align_of::<k_msgq_attrs>(),
        4usize,
        concat!("Alignment of ", stringify!(k_msgq_attrs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq_attrs>())).msg_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq_attrs),
            "::",
            stringify!(msg_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq_attrs>())).max_msgs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq_attrs),
            "::",
            stringify!(max_msgs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_msgq_attrs>())).used_msgs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_msgq_attrs),
            "::",
            stringify!(used_msgs)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a message queue."]
    #[doc = ""]
    #[doc = " This routine initializes a message queue object, prior to its first use."]
    #[doc = ""]
    #[doc = " The message queue\'s ring buffer must contain space for @a max_msgs messages,"]
    #[doc = " each of which is @a msg_size bytes long. The buffer must be aligned to an"]
    #[doc = " N-byte boundary, where N is a power of 2 (i.e. 1, 2, 4, ...). To ensure"]
    #[doc = " that each message is similarly aligned to this boundary, @a q_msg_size"]
    #[doc = " must also be a multiple of N."]
    #[doc = ""]
    #[doc = " @param q Address of the message queue."]
    #[doc = " @param buffer Pointer to ring buffer that holds queued messages."]
    #[doc = " @param msg_size Message size (in bytes)."]
    #[doc = " @param max_msgs Maximum number of messages that can be queued."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-MSGQ-002"]
    pub fn k_msgq_init(q: *mut k_msgq, buffer: *mut cty::c_char, msg_size: usize, max_msgs: u32_t);
}
extern "C" {
    pub fn k_msgq_cleanup(q: *mut k_msgq);
}
#[doc = " @defgroup mem_pool_apis Memory Pool APIs"]
#[doc = " @ingroup kernel_apis"]
#[doc = " @{"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct k_mem_block_id {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_k_mem_block_id() {
    assert_eq!(
        ::core::mem::size_of::<k_mem_block_id>(),
        4usize,
        concat!("Size of: ", stringify!(k_mem_block_id))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mem_block_id>(),
        4usize,
        concat!("Alignment of ", stringify!(k_mem_block_id))
    );
}
impl k_mem_block_id {
    #[inline]
    pub fn pool(&self) -> u32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pool(&mut self, val: u32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn level(&self) -> u32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_level(&mut self, val: u32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn block(&self) -> u32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_block(&mut self, val: u32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pool: u32_t,
        level: u32_t,
        block: u32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let pool: u32 = unsafe { ::core::mem::transmute(pool) };
            pool as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let level: u32 = unsafe { ::core::mem::transmute(level) };
            level as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let block: u32 = unsafe { ::core::mem::transmute(block) };
            block as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_mem_block {
    pub data: *mut cty::c_void,
    pub id: k_mem_block_id,
}
#[test]
fn bindgen_test_layout_k_mem_block() {
    assert_eq!(
        ::core::mem::size_of::<k_mem_block>(),
        8usize,
        concat!("Size of: ", stringify!(k_mem_block))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mem_block>(),
        4usize,
        concat!("Alignment of ", stringify!(k_mem_block))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_block>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_block),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_block>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_block),
            "::",
            stringify!(id)
        )
    );
}
#[doc = " @defgroup mailbox_apis Mailbox APIs"]
#[doc = " @ingroup kernel_apis"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_mbox_msg {
    #[doc = " internal use only - needed for legacy API support"]
    pub _mailbox: u32_t,
    #[doc = " size of message (in bytes)"]
    pub size: usize,
    #[doc = " application-defined information value"]
    pub info: u32_t,
    #[doc = " sender\'s message data buffer"]
    pub tx_data: *mut cty::c_void,
    #[doc = " internal use only - needed for legacy API support"]
    pub _rx_data: *mut cty::c_void,
    #[doc = " message data block descriptor"]
    pub tx_block: k_mem_block,
    #[doc = " source thread id"]
    pub rx_source_thread: k_tid_t,
    #[doc = " target thread id"]
    pub tx_target_thread: k_tid_t,
    #[doc = " internal use only - thread waiting on send (may be a dummy)"]
    pub _syncing_thread: k_tid_t,
    #[doc = " internal use only - semaphore used during asynchronous send"]
    pub _async_sem: *mut k_sem,
}
#[test]
fn bindgen_test_layout_k_mbox_msg() {
    assert_eq!(
        ::core::mem::size_of::<k_mbox_msg>(),
        44usize,
        concat!("Size of: ", stringify!(k_mbox_msg))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mbox_msg>(),
        4usize,
        concat!("Alignment of ", stringify!(k_mbox_msg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox_msg>()))._mailbox as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(_mailbox)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox_msg>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox_msg>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox_msg>())).tx_data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(tx_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox_msg>()))._rx_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(_rx_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox_msg>())).tx_block as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(tx_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox_msg>())).rx_source_thread as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(rx_source_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox_msg>())).tx_target_thread as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(tx_target_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox_msg>()))._syncing_thread as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(_syncing_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox_msg>()))._async_sem as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox_msg),
            "::",
            stringify!(_async_sem)
        )
    );
}
#[repr(C)]
pub struct k_mbox {
    pub tx_msg_queue: _wait_q_t,
    pub rx_msg_queue: _wait_q_t,
    pub __dummy_next: __IncompleteArrayField<u8_t>,
}
#[test]
fn bindgen_test_layout_k_mbox() {
    assert_eq!(
        ::core::mem::size_of::<k_mbox>(),
        16usize,
        concat!("Size of: ", stringify!(k_mbox))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mbox>(),
        4usize,
        concat!("Alignment of ", stringify!(k_mbox))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox>())).tx_msg_queue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox),
            "::",
            stringify!(tx_msg_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox>())).rx_msg_queue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox),
            "::",
            stringify!(rx_msg_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mbox>())).__dummy_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mbox),
            "::",
            stringify!(__dummy_next)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a mailbox."]
    #[doc = ""]
    #[doc = " This routine initializes a mailbox object, prior to its first use."]
    #[doc = ""]
    #[doc = " @param mbox Address of the mailbox."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-MBOX-002"]
    pub fn k_mbox_init(mbox: *mut k_mbox);
}
extern "C" {
    #[doc = " @brief Send a mailbox message in a synchronous manner."]
    #[doc = ""]
    #[doc = " This routine sends a message to @a mbox and waits for a receiver to both"]
    #[doc = " receive and process it. The message data may be in a buffer, in a memory"]
    #[doc = " pool block, or non-existent (i.e. an empty message)."]
    #[doc = ""]
    #[doc = " @param mbox Address of the mailbox."]
    #[doc = " @param tx_msg Address of the transmit message descriptor."]
    #[doc = " @param timeout Waiting period for the message to be received (in"]
    #[doc = "                milliseconds), or one of the special values K_NO_WAIT"]
    #[doc = "                and K_FOREVER. Once the message has been received,"]
    #[doc = "                this routine waits as long as necessary for the message"]
    #[doc = "                to be completely processed."]
    #[doc = ""]
    #[doc = " @retval 0 Message sent."]
    #[doc = " @retval -ENOMSG Returned without waiting."]
    #[doc = " @retval -EAGAIN Waiting period timed out."]
    #[doc = " @req K-MBOX-002"]
    pub fn k_mbox_put(mbox: *mut k_mbox, tx_msg: *mut k_mbox_msg, timeout: s32_t) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Send a mailbox message in an asynchronous manner."]
    #[doc = ""]
    #[doc = " This routine sends a message to @a mbox without waiting for a receiver"]
    #[doc = " to process it. The message data may be in a buffer, in a memory pool block,"]
    #[doc = " or non-existent (i.e. an empty message). Optionally, the semaphore @a sem"]
    #[doc = " will be given when the message has been both received and completely"]
    #[doc = " processed by the receiver."]
    #[doc = ""]
    #[doc = " @param mbox Address of the mailbox."]
    #[doc = " @param tx_msg Address of the transmit message descriptor."]
    #[doc = " @param sem Address of a semaphore, or NULL if none is needed."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-MBOX-002"]
    pub fn k_mbox_async_put(mbox: *mut k_mbox, tx_msg: *mut k_mbox_msg, sem: *mut k_sem);
}
extern "C" {
    #[doc = " @brief Receive a mailbox message."]
    #[doc = ""]
    #[doc = " This routine receives a message from @a mbox, then optionally retrieves"]
    #[doc = " its data and disposes of the message."]
    #[doc = ""]
    #[doc = " @param mbox Address of the mailbox."]
    #[doc = " @param rx_msg Address of the receive message descriptor."]
    #[doc = " @param buffer Address of the buffer to receive data, or NULL to defer data"]
    #[doc = "               retrieval and message disposal until later."]
    #[doc = " @param timeout Waiting period for a message to be received (in"]
    #[doc = "                milliseconds), or one of the special values K_NO_WAIT"]
    #[doc = "                and K_FOREVER."]
    #[doc = ""]
    #[doc = " @retval 0 Message received."]
    #[doc = " @retval -ENOMSG Returned without waiting."]
    #[doc = " @retval -EAGAIN Waiting period timed out."]
    #[doc = " @req K-MBOX-002"]
    pub fn k_mbox_get(
        mbox: *mut k_mbox,
        rx_msg: *mut k_mbox_msg,
        buffer: *mut cty::c_void,
        timeout: s32_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve mailbox message data into a buffer."]
    #[doc = ""]
    #[doc = " This routine completes the processing of a received message by retrieving"]
    #[doc = " its data into a buffer, then disposing of the message."]
    #[doc = ""]
    #[doc = " Alternatively, this routine can be used to dispose of a received message"]
    #[doc = " without retrieving its data."]
    #[doc = ""]
    #[doc = " @param rx_msg Address of the receive message descriptor."]
    #[doc = " @param buffer Address of the buffer to receive data, or NULL to discard"]
    #[doc = "               the data."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-MBOX-002"]
    pub fn k_mbox_data_get(rx_msg: *mut k_mbox_msg, buffer: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Retrieve mailbox message data into a memory pool block."]
    #[doc = ""]
    #[doc = " This routine completes the processing of a received message by retrieving"]
    #[doc = " its data into a memory pool block, then disposing of the message."]
    #[doc = " The memory pool block that results from successful retrieval must be"]
    #[doc = " returned to the pool once the data has been processed, even in cases"]
    #[doc = " where zero bytes of data are retrieved."]
    #[doc = ""]
    #[doc = " Alternatively, this routine can be used to dispose of a received message"]
    #[doc = " without retrieving its data. In this case there is no need to return a"]
    #[doc = " memory pool block to the pool."]
    #[doc = ""]
    #[doc = " This routine allocates a new memory pool block for the data only if the"]
    #[doc = " data is not already in one. If a new block cannot be allocated, the routine"]
    #[doc = " returns a failure code and the received message is left unchanged. This"]
    #[doc = " permits the caller to reattempt data retrieval at a later time or to dispose"]
    #[doc = " of the received message without retrieving its data."]
    #[doc = ""]
    #[doc = " @param rx_msg Address of a receive message descriptor."]
    #[doc = " @param pool Address of memory pool, or NULL to discard data."]
    #[doc = " @param block Address of the area to hold memory pool block info."]
    #[doc = " @param timeout Waiting period to wait for a memory pool block (in"]
    #[doc = "                milliseconds), or one of the special values K_NO_WAIT"]
    #[doc = "                and K_FOREVER."]
    #[doc = ""]
    #[doc = " @retval 0 Data retrieved."]
    #[doc = " @retval -ENOMEM Returned without waiting."]
    #[doc = " @retval -EAGAIN Waiting period timed out."]
    #[doc = " @req K-MBOX-002"]
    pub fn k_mbox_data_block_get(
        rx_msg: *mut k_mbox_msg,
        pool: *mut k_mem_pool,
        block: *mut k_mem_block,
        timeout: s32_t,
    ) -> cty::c_int;
}
#[doc = " Pipe Structure"]
#[repr(C)]
pub struct k_pipe {
    #[doc = "< Pipe buffer: may be NULL"]
    pub buffer: *mut cty::c_uchar,
    #[doc = "< Buffer size"]
    pub size: usize,
    #[doc = "< # bytes used in buffer"]
    pub bytes_used: usize,
    #[doc = "< Where in buffer to read from"]
    pub read_index: usize,
    #[doc = "< Where in buffer to write"]
    pub write_index: usize,
    pub wait_q: k_pipe__bindgen_ty_1,
    pub __dummy_next: __IncompleteArrayField<u8_t>,
    #[doc = "< Flags"]
    pub flags: u8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_pipe__bindgen_ty_1 {
    #[doc = "< Reader wait queue"]
    pub readers: _wait_q_t,
    #[doc = "< Writer wait queue"]
    pub writers: _wait_q_t,
}
#[test]
fn bindgen_test_layout_k_pipe__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<k_pipe__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(k_pipe__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<k_pipe__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(k_pipe__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_pipe__bindgen_ty_1>())).readers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe__bindgen_ty_1),
            "::",
            stringify!(readers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_pipe__bindgen_ty_1>())).writers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe__bindgen_ty_1),
            "::",
            stringify!(writers)
        )
    );
}
#[test]
fn bindgen_test_layout_k_pipe() {
    assert_eq!(
        ::core::mem::size_of::<k_pipe>(),
        40usize,
        concat!("Size of: ", stringify!(k_pipe))
    );
    assert_eq!(
        ::core::mem::align_of::<k_pipe>(),
        4usize,
        concat!("Alignment of ", stringify!(k_pipe))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_pipe>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_pipe>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_pipe>())).bytes_used as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(bytes_used)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_pipe>())).read_index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(read_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_pipe>())).write_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(write_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_pipe>())).wait_q as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_pipe>())).__dummy_next as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(__dummy_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_pipe>())).flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(k_pipe),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a pipe."]
    #[doc = ""]
    #[doc = " This routine initializes a pipe object, prior to its first use."]
    #[doc = ""]
    #[doc = " @param pipe Address of the pipe."]
    #[doc = " @param buffer Address of the pipe\'s ring buffer, or NULL if no ring buffer"]
    #[doc = "               is used."]
    #[doc = " @param size Size of the pipe\'s ring buffer (in bytes), or zero if no ring"]
    #[doc = "             buffer is used."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-PIPE-002"]
    pub fn k_pipe_init(pipe: *mut k_pipe, buffer: *mut cty::c_uchar, size: usize);
}
extern "C" {
    #[doc = " @brief Release a pipe\'s allocated buffer"]
    #[doc = ""]
    #[doc = " If a pipe object was given a dynamically allocated buffer via"]
    #[doc = " k_pipe_alloc_init(), this will free it. This function does nothing"]
    #[doc = " if the buffer wasn\'t dynamically allocated."]
    #[doc = ""]
    #[doc = " @param pipe Address of the pipe."]
    #[doc = " @req K-PIPE-002"]
    pub fn k_pipe_cleanup(pipe: *mut k_pipe);
}
extern "C" {
    #[doc = " @brief Write memory block to a pipe."]
    #[doc = ""]
    #[doc = " This routine writes the data contained in a memory block to @a pipe."]
    #[doc = " Once all of the data in the block has been written to the pipe, it will"]
    #[doc = " free the memory block @a block and give the semaphore @a sem (if specified)."]
    #[doc = ""]
    #[doc = " @param pipe Address of the pipe."]
    #[doc = " @param block Memory block containing data to send"]
    #[doc = " @param size Number of data bytes in memory block to send"]
    #[doc = " @param sem Semaphore to signal upon completion (else NULL)"]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-PIPE-002"]
    pub fn k_pipe_block_put(
        pipe: *mut k_pipe,
        block: *mut k_mem_block,
        size: usize,
        sem: *mut k_sem,
    );
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
pub struct k_mem_slab {
    pub wait_q: _wait_q_t,
    pub num_blocks: u32_t,
    pub block_size: usize,
    pub buffer: *mut cty::c_char,
    pub free_list: *mut cty::c_char,
    pub num_used: u32_t,
    pub __dummy_next: __IncompleteArrayField<u8_t>,
}
#[test]
fn bindgen_test_layout_k_mem_slab() {
    assert_eq!(
        ::core::mem::size_of::<k_mem_slab>(),
        28usize,
        concat!("Size of: ", stringify!(k_mem_slab))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mem_slab>(),
        4usize,
        concat!("Alignment of ", stringify!(k_mem_slab))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_slab>())).wait_q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(wait_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_slab>())).num_blocks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(num_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_slab>())).block_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_slab>())).buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_slab>())).free_list as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_slab>())).num_used as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(num_used)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_slab>())).__dummy_next as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_slab),
            "::",
            stringify!(__dummy_next)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a memory slab."]
    #[doc = ""]
    #[doc = " Initializes a memory slab, prior to its first use."]
    #[doc = ""]
    #[doc = " The memory slab\'s buffer contains @a slab_num_blocks memory blocks"]
    #[doc = " that are @a slab_block_size bytes long. The buffer must be aligned to an"]
    #[doc = " N-byte boundary, where N is a power of 2 larger than 2 (i.e. 4, 8, 16, ...)."]
    #[doc = " To ensure that each memory block is similarly aligned to this boundary,"]
    #[doc = " @a slab_block_size must also be a multiple of N."]
    #[doc = ""]
    #[doc = " @param slab Address of the memory slab."]
    #[doc = " @param buffer Pointer to buffer used for the memory blocks."]
    #[doc = " @param block_size Size of each memory block (in bytes)."]
    #[doc = " @param num_blocks Number of memory blocks."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-MSLAB-002"]
    pub fn k_mem_slab_init(
        slab: *mut k_mem_slab,
        buffer: *mut cty::c_void,
        block_size: usize,
        num_blocks: u32_t,
    );
}
extern "C" {
    #[doc = " @brief Allocate memory from a memory slab."]
    #[doc = ""]
    #[doc = " This routine allocates a memory block from a memory slab."]
    #[doc = ""]
    #[doc = " @param slab Address of the memory slab."]
    #[doc = " @param mem Pointer to block address area."]
    #[doc = " @param timeout Maximum time to wait for operation to complete"]
    #[doc = "        (in milliseconds). Use K_NO_WAIT to return without waiting,"]
    #[doc = "        or K_FOREVER to wait as long as necessary."]
    #[doc = ""]
    #[doc = " @retval 0 Memory allocated. The block address area pointed at by @a mem"]
    #[doc = "         is set to the starting address of the memory block."]
    #[doc = " @retval -ENOMEM Returned without waiting."]
    #[doc = " @retval -EAGAIN Waiting period timed out."]
    #[doc = " @req K-MSLAB-002"]
    pub fn k_mem_slab_alloc(
        slab: *mut k_mem_slab,
        mem: *mut *mut cty::c_void,
        timeout: s32_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Free memory allocated from a memory slab."]
    #[doc = ""]
    #[doc = " This routine releases a previously allocated memory block back to its"]
    #[doc = " associated memory slab."]
    #[doc = ""]
    #[doc = " @param slab Address of the memory slab."]
    #[doc = " @param mem Pointer to block address area (as set by k_mem_slab_alloc())."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-MSLAB-002"]
    pub fn k_mem_slab_free(slab: *mut k_mem_slab, mem: *mut *mut cty::c_void);
}
#[doc = " @cond INTERNAL_HIDDEN"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_mem_pool {
    pub base: sys_mem_pool_base,
    pub wait_q: _wait_q_t,
}
#[test]
fn bindgen_test_layout_k_mem_pool() {
    assert_eq!(
        ::core::mem::size_of::<k_mem_pool>(),
        28usize,
        concat!("Size of: ", stringify!(k_mem_pool))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mem_pool>(),
        4usize,
        concat!("Alignment of ", stringify!(k_mem_pool))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_pool>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_pool),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_pool>())).wait_q as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_pool),
            "::",
            stringify!(wait_q)
        )
    );
}
extern "C" {
    #[doc = " @brief Allocate memory from a memory pool."]
    #[doc = ""]
    #[doc = " This routine allocates a memory block from a memory pool."]
    #[doc = ""]
    #[doc = " @param pool Address of the memory pool."]
    #[doc = " @param block Pointer to block descriptor for the allocated memory."]
    #[doc = " @param size Amount of memory to allocate (in bytes)."]
    #[doc = " @param timeout Maximum time to wait for operation to complete"]
    #[doc = "        (in milliseconds). Use K_NO_WAIT to return without waiting,"]
    #[doc = "        or K_FOREVER to wait as long as necessary."]
    #[doc = ""]
    #[doc = " @retval 0 Memory allocated. The @a data field of the block descriptor"]
    #[doc = "         is set to the starting address of the memory block."]
    #[doc = " @retval -ENOMEM Returned without waiting."]
    #[doc = " @retval -EAGAIN Waiting period timed out."]
    #[doc = " @req K-MPOOL-002"]
    pub fn k_mem_pool_alloc(
        pool: *mut k_mem_pool,
        block: *mut k_mem_block,
        size: usize,
        timeout: s32_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @brief Allocate memory from a memory pool with malloc() semantics"]
    #[doc = ""]
    #[doc = " Such memory must be released using k_free()."]
    #[doc = ""]
    #[doc = " @param pool Address of the memory pool."]
    #[doc = " @param size Amount of memory to allocate (in bytes)."]
    #[doc = " @return Address of the allocated memory if successful, otherwise NULL"]
    #[doc = " @req K-MPOOL-002"]
    pub fn k_mem_pool_malloc(pool: *mut k_mem_pool, size: usize) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Free memory allocated from a memory pool."]
    #[doc = ""]
    #[doc = " This routine releases a previously allocated memory block back to its"]
    #[doc = " memory pool."]
    #[doc = ""]
    #[doc = " @param block Pointer to block descriptor for the allocated memory."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-MPOOL-002"]
    pub fn k_mem_pool_free(block: *mut k_mem_block);
}
extern "C" {
    #[doc = " @brief Free memory allocated from a memory pool."]
    #[doc = ""]
    #[doc = " This routine releases a previously allocated memory block back to its"]
    #[doc = " memory pool"]
    #[doc = ""]
    #[doc = " @param id Memory block identifier."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-MPOOL-002"]
    pub fn k_mem_pool_free_id(id: *mut k_mem_block_id);
}
extern "C" {
    #[doc = " @brief Allocate memory from heap."]
    #[doc = ""]
    #[doc = " This routine provides traditional malloc() semantics. Memory is"]
    #[doc = " allocated from the heap memory pool."]
    #[doc = ""]
    #[doc = " @param size Amount of memory requested (in bytes)."]
    #[doc = ""]
    #[doc = " @return Address of the allocated memory if successful; otherwise NULL."]
    #[doc = " @req K-HEAP-001"]
    pub fn k_malloc(size: usize) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " @brief Free memory allocated from heap."]
    #[doc = ""]
    #[doc = " This routine provides traditional free() semantics. The memory being"]
    #[doc = " returned must have been allocated from the heap memory pool or"]
    #[doc = " k_mem_pool_malloc()."]
    #[doc = ""]
    #[doc = " If @a ptr is NULL, no operation is performed."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to previously allocated memory."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-HEAP-001"]
    pub fn k_free(ptr: *mut cty::c_void);
}
extern "C" {
    #[doc = " @brief Allocate memory from heap, array style"]
    #[doc = ""]
    #[doc = " This routine provides traditional calloc() semantics. Memory is"]
    #[doc = " allocated from the heap memory pool and zeroed."]
    #[doc = ""]
    #[doc = " @param nmemb Number of elements in the requested array"]
    #[doc = " @param size Size of each array element (in bytes)."]
    #[doc = ""]
    #[doc = " @return Address of the allocated memory if successful; otherwise NULL."]
    #[doc = " @req K-HEAP-001"]
    pub fn k_calloc(nmemb: usize, size: usize) -> *mut cty::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _poller {
    pub thread: *mut k_thread,
    pub is_polling: cty::c_int,
}
#[test]
fn bindgen_test_layout__poller() {
    assert_eq!(
        ::core::mem::size_of::<_poller>(),
        8usize,
        concat!("Size of: ", stringify!(_poller))
    );
    assert_eq!(
        ::core::mem::align_of::<_poller>(),
        4usize,
        concat!("Alignment of ", stringify!(_poller))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_poller>())).thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_poller),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_poller>())).is_polling as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_poller),
            "::",
            stringify!(is_polling)
        )
    );
}
pub const _poll_types_bits__POLL_TYPE_IGNORE: _poll_types_bits = 0;
pub const _poll_types_bits__POLL_TYPE_SIGNAL: _poll_types_bits = 1;
pub const _poll_types_bits__POLL_TYPE_SEM_AVAILABLE: _poll_types_bits = 2;
pub const _poll_types_bits__POLL_TYPE_DATA_AVAILABLE: _poll_types_bits = 3;
pub const _poll_types_bits__POLL_NUM_TYPES: _poll_types_bits = 4;
pub type _poll_types_bits = u32;
pub const _poll_states_bits__POLL_STATE_NOT_READY: _poll_states_bits = 0;
pub const _poll_states_bits__POLL_STATE_SIGNALED: _poll_states_bits = 1;
pub const _poll_states_bits__POLL_STATE_SEM_AVAILABLE: _poll_states_bits = 2;
pub const _poll_states_bits__POLL_STATE_DATA_AVAILABLE: _poll_states_bits = 3;
pub const _poll_states_bits__POLL_STATE_CANCELLED: _poll_states_bits = 4;
pub const _poll_states_bits__POLL_NUM_STATES: _poll_states_bits = 5;
pub type _poll_states_bits = u32;
pub const k_poll_modes_K_POLL_MODE_NOTIFY_ONLY: k_poll_modes = 0;
pub const k_poll_modes_K_POLL_NUM_MODES: k_poll_modes = 1;
pub type k_poll_modes = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_poll_signal {
    pub poll_events: sys_dlist_t,
    pub signaled: cty::c_uint,
    pub result: cty::c_int,
}
#[test]
fn bindgen_test_layout_k_poll_signal() {
    assert_eq!(
        ::core::mem::size_of::<k_poll_signal>(),
        16usize,
        concat!("Size of: ", stringify!(k_poll_signal))
    );
    assert_eq!(
        ::core::mem::align_of::<k_poll_signal>(),
        4usize,
        concat!("Alignment of ", stringify!(k_poll_signal))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_poll_signal>())).poll_events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_signal),
            "::",
            stringify!(poll_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_poll_signal>())).signaled as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_signal),
            "::",
            stringify!(signaled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_poll_signal>())).result as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_signal),
            "::",
            stringify!(result)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_poll_event {
    pub _node: sys_dnode_t,
    pub poller: *mut _poller,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_anon_1: k_poll_event__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_poll_event__bindgen_ty_1 {
    pub obj: *mut cty::c_void,
    pub signal: *mut k_poll_signal,
    pub sem: *mut k_sem,
    pub fifo: *mut k_fifo,
    pub queue: *mut k_queue,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_k_poll_event__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<k_poll_event__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(k_poll_event__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<k_poll_event__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(k_poll_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_poll_event__bindgen_ty_1>())).obj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event__bindgen_ty_1),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<k_poll_event__bindgen_ty_1>())).signal as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event__bindgen_ty_1),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_poll_event__bindgen_ty_1>())).sem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event__bindgen_ty_1),
            "::",
            stringify!(sem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<k_poll_event__bindgen_ty_1>())).fifo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event__bindgen_ty_1),
            "::",
            stringify!(fifo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<k_poll_event__bindgen_ty_1>())).queue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event__bindgen_ty_1),
            "::",
            stringify!(queue)
        )
    );
}
#[test]
fn bindgen_test_layout_k_poll_event() {
    assert_eq!(
        ::core::mem::size_of::<k_poll_event>(),
        20usize,
        concat!("Size of: ", stringify!(k_poll_event))
    );
    assert_eq!(
        ::core::mem::align_of::<k_poll_event>(),
        4usize,
        concat!("Alignment of ", stringify!(k_poll_event))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_poll_event>()))._node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event),
            "::",
            stringify!(_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_poll_event>())).poller as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_poll_event),
            "::",
            stringify!(poller)
        )
    );
}
impl k_poll_event {
    #[inline]
    pub fn tag(&self) -> u32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tag(&mut self, val: u32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn state(&self) -> u32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mode(&self) -> u32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: u32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tag: u32_t,
        type_: u32_t,
        state: u32_t,
        mode: u32_t,
        unused: u32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let tag: u32 = unsafe { ::core::mem::transmute(tag) };
            tag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let state: u32 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let mode: u32 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let unused: u32 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Initialize one struct k_poll_event instance"]
    #[doc = ""]
    #[doc = " After this routine is called on a poll event, the event it ready to be"]
    #[doc = " placed in an event array to be passed to k_poll()."]
    #[doc = ""]
    #[doc = " @param event The event to initialize."]
    #[doc = " @param type A bitfield of the types of event, from the K_POLL_TYPE_xxx"]
    #[doc = "             values. Only values that apply to the same object being polled"]
    #[doc = "             can be used together. Choosing K_POLL_TYPE_IGNORE disables the"]
    #[doc = "             event."]
    #[doc = " @param mode Future. Use K_POLL_MODE_NOTIFY_ONLY."]
    #[doc = " @param obj Kernel object or poll signal."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-POLL-001"]
    pub fn k_poll_event_init(
        event: *mut k_poll_event,
        type_: u32_t,
        mode: cty::c_int,
        obj: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @internal"]
    pub fn _handle_obj_poll_events(events: *mut sys_dlist_t, state: u32_t);
}
extern "C" {
    #[doc = " @brief Make the CPU idle in an atomic fashion."]
    #[doc = ""]
    #[doc = " Similar to k_cpu_idle(), but called with interrupts locked if operations"]
    #[doc = " must be done atomically before making the CPU idle."]
    #[doc = ""]
    #[doc = " @param key Interrupt locking key obtained from irq_lock()."]
    #[doc = ""]
    #[doc = " @return N/A"]
    #[doc = " @req K-MISC-002"]
    pub fn k_cpu_atomic_idle(key: cty::c_uint);
}
extern "C" {
    #[doc = " @internal"]
    pub fn _sys_power_save_idle_exit(ticks: s32_t);
}
extern "C" {
    #[doc = " @internal"]
    pub fn _init_static_threads();
}
extern "C" {
    #[doc = " @internal"]
    pub fn _is_thread_essential() -> cty::c_int;
}
extern "C" {
    #[doc = " @internal"]
    pub fn _timer_expiration_handler(t: *mut _timeout);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_mem_partition {
    pub start: u32_t,
    pub size: u32_t,
}
#[test]
fn bindgen_test_layout_k_mem_partition() {
    assert_eq!(
        ::core::mem::size_of::<k_mem_partition>(),
        8usize,
        concat!("Size of: ", stringify!(k_mem_partition))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mem_partition>(),
        4usize,
        concat!("Alignment of ", stringify!(k_mem_partition))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_partition>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_partition),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_partition>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_partition),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_mem_domain {
    pub mem_domain_q: sys_dlist_t,
    pub num_partitions: u8_t,
}
#[test]
fn bindgen_test_layout_k_mem_domain() {
    assert_eq!(
        ::core::mem::size_of::<k_mem_domain>(),
        12usize,
        concat!("Size of: ", stringify!(k_mem_domain))
    );
    assert_eq!(
        ::core::mem::align_of::<k_mem_domain>(),
        4usize,
        concat!("Alignment of ", stringify!(k_mem_domain))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_domain>())).mem_domain_q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_domain),
            "::",
            stringify!(mem_domain_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<k_mem_domain>())).num_partitions as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(k_mem_domain),
            "::",
            stringify!(num_partitions)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize a memory domain."]
    #[doc = ""]
    #[doc = " Initialize a memory domain with given name and memory partitions."]
    #[doc = ""]
    #[doc = " @param domain The memory domain to be initialized."]
    #[doc = " @param num_parts The number of array items of \"parts\" parameter."]
    #[doc = " @param parts An array of pointers to the memory partitions. Can be NULL"]
    #[doc = "              if num_parts is zero."]
    #[doc = " @req K-MD-001"]
    pub fn k_mem_domain_init(
        domain: *mut k_mem_domain,
        num_parts: u8_t,
        parts: *mut *mut k_mem_partition,
    );
}
extern "C" {
    #[doc = " @brief Destroy a memory domain."]
    #[doc = ""]
    #[doc = " Destroy a memory domain."]
    #[doc = ""]
    #[doc = " @param domain The memory domain to be destroyed."]
    #[doc = " @req K-MD-001"]
    pub fn k_mem_domain_destroy(domain: *mut k_mem_domain);
}
extern "C" {
    #[doc = " @brief Add a memory partition into a memory domain."]
    #[doc = ""]
    #[doc = " Add a memory partition into a memory domain."]
    #[doc = ""]
    #[doc = " @param domain The memory domain to be added a memory partition."]
    #[doc = " @param part The memory partition to be added"]
    #[doc = " @req K-MD-001"]
    pub fn k_mem_domain_add_partition(domain: *mut k_mem_domain, part: *mut k_mem_partition);
}
extern "C" {
    #[doc = " @brief Remove a memory partition from a memory domain."]
    #[doc = ""]
    #[doc = " Remove a memory partition from a memory domain."]
    #[doc = ""]
    #[doc = " @param domain The memory domain to be removed a memory partition."]
    #[doc = " @param part The memory partition to be removed"]
    #[doc = " @req K-MD-001"]
    pub fn k_mem_domain_remove_partition(domain: *mut k_mem_domain, part: *mut k_mem_partition);
}
extern "C" {
    #[doc = " @brief Add a thread into a memory domain."]
    #[doc = ""]
    #[doc = " Add a thread into a memory domain."]
    #[doc = ""]
    #[doc = " @param domain The memory domain that the thread is going to be added into."]
    #[doc = " @param thread ID of thread going to be added into the memory domain."]
    #[doc = ""]
    #[doc = " @req K-MD-001"]
    pub fn k_mem_domain_add_thread(domain: *mut k_mem_domain, thread: k_tid_t);
}
extern "C" {
    #[doc = " @brief Remove a thread from its memory domain."]
    #[doc = ""]
    #[doc = " Remove a thread from its memory domain."]
    #[doc = ""]
    #[doc = " @param thread ID of thread going to be removed from its memory domain."]
    #[doc = " @req K-MD-001"]
    pub fn k_mem_domain_remove_thread(thread: k_tid_t);
}
extern "C" {
    #[doc = " @brief Start a numbered CPU on a MP-capable system"]
    #[doc = ""]
    #[doc = " This starts and initializes a specific CPU.  The main thread on"]
    #[doc = " startup is running on CPU zero, other processors are numbered"]
    #[doc = " sequentially.  On return from this function, the CPU is known to"]
    #[doc = " have begun operating and will enter the provided function.  Its"]
    #[doc = " interrupts will be initialized but disabled such that irq_unlock()"]
    #[doc = " with the provided key will work to enable them."]
    #[doc = ""]
    #[doc = " Normally, in SMP mode this function will be called by the kernel"]
    #[doc = " initialization and should not be used as a user API.  But it is"]
    #[doc = " defined here for special-purpose apps which want Zephyr running on"]
    #[doc = " one core and to use others for design-specific processing."]
    #[doc = ""]
    #[doc = " @param cpu_num Integer number of the CPU"]
    #[doc = " @param stack Stack memory for the CPU"]
    #[doc = " @param sz Stack buffer size, in bytes"]
    #[doc = " @param fn Function to begin running on the CPU.  First argument is"]
    #[doc = "        an irq_unlock() key."]
    #[doc = " @param arg Untyped argument to be passed to \"fn\""]
    pub fn _arch_start_cpu(
        cpu_num: cty::c_int,
        stack: *mut k_thread_stack_t,
        sz: cty::c_int,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int, arg2: *mut cty::c_void)>,
        arg: *mut cty::c_void,
    );
}
extern "C" {
    pub fn _impl_k_thread_create(
        new_thread: *mut k_thread,
        stack: *mut k_thread_stack_t,
        stack_size: usize,
        entry: k_thread_entry_t,
        p1: *mut cty::c_void,
        p2: *mut cty::c_void,
        p3: *mut cty::c_void,
        prio: cty::c_int,
        options: u32_t,
        delay: s32_t,
    ) -> k_tid_t;
}
extern "C" {
    pub fn _impl_k_sleep(duration: s32_t) -> s32_t;
}
extern "C" {
    pub fn _impl_k_busy_wait(usec_to_wait: u32_t);
}
extern "C" {
    pub fn _impl_k_yield();
}
extern "C" {
    pub fn _impl_k_wakeup(thread: k_tid_t);
}
extern "C" {
    pub fn _impl_k_current_get() -> k_tid_t;
}
extern "C" {
    pub fn _impl_k_thread_abort(thread: k_tid_t);
}
extern "C" {
    pub fn _impl_k_thread_start(thread: k_tid_t);
}
extern "C" {
    pub fn _impl_k_thread_priority_get(thread: k_tid_t) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_thread_priority_set(thread: k_tid_t, prio: cty::c_int);
}
extern "C" {
    pub fn _impl_k_thread_deadline_set(thread: k_tid_t, deadline: cty::c_int);
}
extern "C" {
    pub fn _impl_k_thread_suspend(thread: k_tid_t);
}
extern "C" {
    pub fn _impl_k_thread_resume(thread: k_tid_t);
}
extern "C" {
    pub fn _impl_k_is_preempt_thread() -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_thread_custom_data_set(value: *mut cty::c_void);
}
extern "C" {
    pub fn _impl_k_thread_custom_data_get() -> *mut cty::c_void;
}
extern "C" {
    pub fn _impl_k_thread_name_set(thread_id: k_tid_t, value: *const cty::c_char);
}
extern "C" {
    pub fn _impl_k_thread_name_get(thread_id: k_tid_t) -> *const cty::c_char;
}
extern "C" {
    pub fn _impl_k_timer_start(timer: *mut k_timer, duration: s32_t, period: s32_t);
}
extern "C" {
    pub fn _impl_k_timer_stop(timer: *mut k_timer);
}
extern "C" {
    pub fn _impl_k_timer_status_get(timer: *mut k_timer) -> u32_t;
}
extern "C" {
    pub fn _impl_k_timer_status_sync(timer: *mut k_timer) -> u32_t;
}
extern "C" {
    pub fn _impl_k_uptime_get() -> s64_t;
}
extern "C" {
    pub fn _impl_k_uptime_get_32() -> u32_t;
}
extern "C" {
    pub fn _impl_k_queue_init(queue: *mut k_queue);
}
extern "C" {
    pub fn _impl_k_queue_cancel_wait(queue: *mut k_queue);
}
extern "C" {
    pub fn _impl_k_queue_alloc_append(queue: *mut k_queue, data: *mut cty::c_void) -> s32_t;
}
extern "C" {
    pub fn _impl_k_queue_alloc_prepend(queue: *mut k_queue, data: *mut cty::c_void) -> s32_t;
}
extern "C" {
    pub fn _impl_k_queue_get(queue: *mut k_queue, timeout: s32_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn _impl_k_stack_alloc_init(stack: *mut k_stack, num_entries: u32_t) -> s32_t;
}
extern "C" {
    pub fn _impl_k_stack_push(stack: *mut k_stack, data: u32_t);
}
extern "C" {
    pub fn _impl_k_stack_pop(stack: *mut k_stack, data: *mut u32_t, timeout: s32_t) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_mutex_init(mutex: *mut k_mutex);
}
extern "C" {
    pub fn _impl_k_mutex_lock(mutex: *mut k_mutex, timeout: s32_t) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_mutex_unlock(mutex: *mut k_mutex);
}
extern "C" {
    pub fn _impl_k_sem_init(sem: *mut k_sem, initial_count: cty::c_uint, limit: cty::c_uint);
}
extern "C" {
    pub fn _impl_k_sem_take(sem: *mut k_sem, timeout: s32_t) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_sem_give(sem: *mut k_sem);
}
extern "C" {
    pub fn _impl_k_alert_recv(alert: *mut k_alert, timeout: s32_t) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_alert_send(alert: *mut k_alert);
}
extern "C" {
    pub fn _impl_k_msgq_alloc_init(q: *mut k_msgq, msg_size: usize, max_msgs: u32_t) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_msgq_put(q: *mut k_msgq, data: *mut cty::c_void, timeout: s32_t) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_msgq_get(q: *mut k_msgq, data: *mut cty::c_void, timeout: s32_t) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_msgq_peek(q: *mut k_msgq, data: *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_msgq_purge(q: *mut k_msgq);
}
extern "C" {
    pub fn _impl_k_msgq_get_attrs(q: *mut k_msgq, attrs: *mut k_msgq_attrs);
}
extern "C" {
    pub fn _impl_k_pipe_alloc_init(pipe: *mut k_pipe, size: usize) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_pipe_put(
        pipe: *mut k_pipe,
        data: *mut cty::c_void,
        bytes_to_write: usize,
        bytes_written: *mut usize,
        min_xfer: usize,
        timeout: s32_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_pipe_get(
        pipe: *mut k_pipe,
        data: *mut cty::c_void,
        bytes_to_read: usize,
        bytes_read: *mut usize,
        min_xfer: usize,
        timeout: s32_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_poll(
        events: *mut k_poll_event,
        num_events: cty::c_int,
        timeout: s32_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_poll_signal_init(signal: *mut k_poll_signal);
}
extern "C" {
    pub fn _impl_k_poll_signal_check(
        signal: *mut k_poll_signal,
        signaled: *mut cty::c_uint,
        result: *mut cty::c_int,
    );
}
extern "C" {
    pub fn _impl_k_poll_signal_raise(signal: *mut k_poll_signal, result: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _impl_k_str_out(c: *mut cty::c_char, n: usize);
}
#[doc = " @brief Static device information (In ROM) Per driver instance"]
#[doc = ""]
#[doc = " @param name name of the device"]
#[doc = " @param init init function for the driver"]
#[doc = " @param config_info address of driver instance config information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_config {
    pub name: *const cty::c_char,
    pub init: ::core::option::Option<unsafe extern "C" fn(device: *mut device) -> cty::c_int>,
    pub config_info: *const cty::c_void,
}
#[test]
fn bindgen_test_layout_device_config() {
    assert_eq!(
        ::core::mem::size_of::<device_config>(),
        12usize,
        concat!("Size of: ", stringify!(device_config))
    );
    assert_eq!(
        ::core::mem::align_of::<device_config>(),
        4usize,
        concat!("Alignment of ", stringify!(device_config))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_config>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device_config),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_config>())).init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(device_config),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device_config>())).config_info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(device_config),
            "::",
            stringify!(config_info)
        )
    );
}
#[doc = " @brief Runtime device structure (In memory) Per driver instance"]
#[doc = " @param device_config Build time config information"]
#[doc = " @param driver_api pointer to structure containing the API functions for"]
#[doc = " the device type. This pointer is filled in by the driver at init time."]
#[doc = " @param driver_data driver instance data. For driver use only"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    pub config: *mut device_config,
    pub driver_api: *const cty::c_void,
    pub driver_data: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_device() {
    assert_eq!(
        ::core::mem::size_of::<device>(),
        12usize,
        concat!("Size of: ", stringify!(device))
    );
    assert_eq!(
        ::core::mem::align_of::<device>(),
        4usize,
        concat!("Alignment of ", stringify!(device))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).driver_api as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(driver_api)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<device>())).driver_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(device),
            "::",
            stringify!(driver_data)
        )
    );
}
extern "C" {
    pub fn _sys_device_do_config_level(level: s32_t);
}
extern "C" {
    #[doc = " @brief Indicate that the device is in the middle of a transaction"]
    #[doc = ""]
    #[doc = " Called by a device driver to indicate that it is in the middle of a"]
    #[doc = " transaction."]
    #[doc = ""]
    #[doc = " @param busy_dev Pointer to device structure of the driver instance."]
    pub fn device_busy_set(busy_dev: *mut device);
}
extern "C" {
    #[doc = " @brief Indicate that the device has completed its transaction"]
    #[doc = ""]
    #[doc = " Called by a device driver to indicate the end of a transaction."]
    #[doc = ""]
    #[doc = " @param busy_dev Pointer to device structure of the driver instance."]
    pub fn device_busy_clear(busy_dev: *mut device);
}
extern "C" {
    pub fn _impl_device_get_binding(name: *const cty::c_char) -> *mut device;
}
#[doc = " @brief UART controller configuration structure"]
#[doc = ""]
#[doc = " @param baudrate  Baudrate setting in bps"]
#[doc = " @param parity    Parity bit, use @ref uart_config_parity"]
#[doc = " @param stop_bits Stop bits, use @ref uart_config_stop_bits"]
#[doc = " @param data_bits Data bits, use @ref uart_config_data_bits"]
#[doc = " @param flow_ctrl Flow control setting, use @ref uart_config_flow_control"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_config {
    pub baudrate: u32_t,
    pub parity: u8_t,
    pub stop_bits: u8_t,
    pub data_bits: u8_t,
    pub flow_ctrl: u8_t,
}
#[test]
fn bindgen_test_layout_uart_config() {
    assert_eq!(
        ::core::mem::size_of::<uart_config>(),
        8usize,
        concat!("Size of: ", stringify!(uart_config))
    );
    assert_eq!(
        ::core::mem::align_of::<uart_config>(),
        4usize,
        concat!("Alignment of ", stringify!(uart_config))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uart_config>())).baudrate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_config),
            "::",
            stringify!(baudrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uart_config>())).parity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_config),
            "::",
            stringify!(parity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uart_config>())).stop_bits as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_config),
            "::",
            stringify!(stop_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uart_config>())).data_bits as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_config),
            "::",
            stringify!(data_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uart_config>())).flow_ctrl as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_config),
            "::",
            stringify!(flow_ctrl)
        )
    );
}
pub const uart_config_parity_UART_CFG_PARITY_NONE: uart_config_parity = 0;
pub const uart_config_parity_UART_CFG_PARITY_ODD: uart_config_parity = 1;
pub const uart_config_parity_UART_CFG_PARITY_EVEN: uart_config_parity = 2;
pub const uart_config_parity_UART_CFG_PARITY_MARK: uart_config_parity = 3;
pub const uart_config_parity_UART_CFG_PARITY_SPACE: uart_config_parity = 4;
#[doc = " @brief Parity modes"]
pub type uart_config_parity = u32;
pub const uart_config_stop_bits_UART_CFG_STOP_BITS_0_5: uart_config_stop_bits = 0;
pub const uart_config_stop_bits_UART_CFG_STOP_BITS_1: uart_config_stop_bits = 1;
pub const uart_config_stop_bits_UART_CFG_STOP_BITS_1_5: uart_config_stop_bits = 2;
pub const uart_config_stop_bits_UART_CFG_STOP_BITS_2: uart_config_stop_bits = 3;
#[doc = " @brief Number of stop bits."]
pub type uart_config_stop_bits = u32;
pub const uart_config_data_bits_UART_CFG_DATA_BITS_5: uart_config_data_bits = 0;
pub const uart_config_data_bits_UART_CFG_DATA_BITS_6: uart_config_data_bits = 1;
pub const uart_config_data_bits_UART_CFG_DATA_BITS_7: uart_config_data_bits = 2;
pub const uart_config_data_bits_UART_CFG_DATA_BITS_8: uart_config_data_bits = 3;
#[doc = " @brief Number of data bits."]
pub type uart_config_data_bits = u32;
pub const uart_config_flow_control_UART_CFG_FLOW_CTRL_NONE: uart_config_flow_control = 0;
pub const uart_config_flow_control_UART_CFG_FLOW_CTRL_RTS_CTS: uart_config_flow_control = 1;
pub const uart_config_flow_control_UART_CFG_FLOW_CTRL_DTR_DSR: uart_config_flow_control = 2;
#[doc = " @brief Hardware flow control options."]
#[doc = ""]
#[doc = " With flow control set to none, any operations related to flow control"]
#[doc = " signals can be managed by user with uart_line_ctrl functions."]
#[doc = " In other cases, flow control is managed by hardware/driver."]
pub type uart_config_flow_control = u32;
#[doc = " @typedef uart_irq_callback_user_data_t"]
#[doc = " @brief Define the application callback function signature for"]
#[doc = " uart_irq_callback_user_data_set() function."]
#[doc = ""]
#[doc = " @param user_data Arbitrary user data."]
pub type uart_irq_callback_user_data_t =
    ::core::option::Option<unsafe extern "C" fn(user_data: *mut cty::c_void)>;
#[doc = " @typedef uart_irq_callback_t"]
#[doc = " @brief Define the application callback function signature for legacy"]
#[doc = " uart_irq_callback_set()."]
#[doc = ""]
#[doc = " @param port Device struct for the UART device."]
pub type uart_irq_callback_t = ::core::option::Option<unsafe extern "C" fn(port: *mut device)>;
#[doc = " @typedef uart_irq_config_func_t"]
#[doc = " @brief For configuring IRQ on each individual UART device."]
#[doc = ""]
#[doc = " @internal"]
pub type uart_irq_config_func_t = ::core::option::Option<unsafe extern "C" fn(port: *mut device)>;
#[doc = " @brief UART device configuration."]
#[doc = ""]
#[doc = " @param port Base port number"]
#[doc = " @param base Memory mapped base address"]
#[doc = " @param regs Register address"]
#[doc = " @param sys_clk_freq System clock frequency in Hz"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uart_device_config {
    pub __bindgen_anon_1: uart_device_config__bindgen_ty_1,
    pub sys_clk_freq: u32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_device_config__bindgen_ty_1 {
    pub port: u32_t,
    pub base: *mut u8_t,
    pub regs: u32_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_uart_device_config__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<uart_device_config__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(uart_device_config__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<uart_device_config__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(uart_device_config__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uart_device_config__bindgen_ty_1>())).port as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_device_config__bindgen_ty_1),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uart_device_config__bindgen_ty_1>())).base as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_device_config__bindgen_ty_1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uart_device_config__bindgen_ty_1>())).regs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_device_config__bindgen_ty_1),
            "::",
            stringify!(regs)
        )
    );
}
#[test]
fn bindgen_test_layout_uart_device_config() {
    assert_eq!(
        ::core::mem::size_of::<uart_device_config>(),
        8usize,
        concat!("Size of: ", stringify!(uart_device_config))
    );
    assert_eq!(
        ::core::mem::align_of::<uart_device_config>(),
        4usize,
        concat!("Alignment of ", stringify!(uart_device_config))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<uart_device_config>())).sys_clk_freq as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_device_config),
            "::",
            stringify!(sys_clk_freq)
        )
    );
}
#[doc = " @brief Driver API structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_driver_api {
    #[doc = " Console I/O function"]
    pub poll_in: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, p_char: *mut cty::c_uchar) -> cty::c_int,
    >,
    pub poll_out:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device, out_char: cty::c_uchar)>,
    #[doc = " Console I/O function"]
    pub err_check: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> cty::c_int>,
    #[doc = " UART configuration functions"]
    pub configure: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, cfg: *const uart_config) -> cty::c_int,
    >,
    pub config_get: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, cfg: *mut uart_config) -> cty::c_int,
    >,
}
#[test]
fn bindgen_test_layout_uart_driver_api() {
    assert_eq!(
        ::core::mem::size_of::<uart_driver_api>(),
        20usize,
        concat!("Size of: ", stringify!(uart_driver_api))
    );
    assert_eq!(
        ::core::mem::align_of::<uart_driver_api>(),
        4usize,
        concat!("Alignment of ", stringify!(uart_driver_api))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uart_driver_api>())).poll_in as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_driver_api),
            "::",
            stringify!(poll_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uart_driver_api>())).poll_out as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_driver_api),
            "::",
            stringify!(poll_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uart_driver_api>())).err_check as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_driver_api),
            "::",
            stringify!(err_check)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uart_driver_api>())).configure as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_driver_api),
            "::",
            stringify!(configure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uart_driver_api>())).config_get as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uart_driver_api),
            "::",
            stringify!(config_get)
        )
    );
}
extern "C" {
    pub fn _impl_uart_irq_tx_enable(dev: *mut device);
}
extern "C" {
    pub fn _impl_uart_irq_tx_disable(dev: *mut device);
}
extern "C" {
    pub fn _impl_uart_irq_rx_enable(dev: *mut device);
}
extern "C" {
    pub fn _impl_uart_irq_rx_disable(dev: *mut device);
}
extern "C" {
    pub fn _impl_uart_irq_err_enable(dev: *mut device);
}
extern "C" {
    pub fn _impl_uart_irq_err_disable(dev: *mut device);
}
extern "C" {
    pub fn _impl_uart_irq_is_pending(dev: *mut device) -> cty::c_int;
}
extern "C" {
    pub fn _impl_uart_irq_update(dev: *mut device) -> cty::c_int;
}
extern "C" {
    pub fn _impl_uart_line_ctrl_set(dev: *mut device, ctrl: u32_t, val: u32_t) -> cty::c_int;
}
extern "C" {
    pub fn _impl_uart_line_ctrl_get(dev: *mut device, ctrl: u32_t, val: *mut u32_t) -> cty::c_int;
}
extern "C" {
    pub fn _impl_uart_drv_cmd(dev: *mut device, cmd: u32_t, p: u32_t) -> cty::c_int;
}
pub type __builtin_va_list = *mut cty::c_char;
